<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="RAC," />





  <link rel="alternate" href="/atom.xml" title="EricHuang's blog" type="application/atom+xml" />






<meta name="description" content="RACCommandRACCommand 在 ReactiveObjc 中是比较复杂的类，对于大多数人尤其是初学者并不会经常使用他。 在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。  简介RACCommand 与 RACSignal 等元素是不同的，RACComma">
<meta name="keywords" content="RAC">
<meta property="og:type" content="article">
<meta property="og:title" content="RACCommand的用法">
<meta property="og:url" content="https://huangzhifei.github.io/2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/index.html">
<meta property="og:site_name" content="EricHuang&#39;s blog">
<meta property="og:description" content="RACCommandRACCommand 在 ReactiveObjc 中是比较复杂的类，对于大多数人尤其是初学者并不会经常使用他。 在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。  简介RACCommand 与 RACSignal 等元素是不同的，RACComma">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACCommand.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execute-For-RACCommand.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Multiple-Executes.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execute-on-RACCommand.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/immediateExecuting-Signal-in-RACCommand.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/MoreExecutionAllowed-Signal.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCommand-Interface.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execution-Signals.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Executing-Signal.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Immediate-Enabled-Signal.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Errors-Signals.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCommand-Side-Effect.png">
<meta property="og:updated_time" content="2020-01-05T02:55:03.370Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RACCommand的用法">
<meta name="twitter:description" content="RACCommandRACCommand 在 ReactiveObjc 中是比较复杂的类，对于大多数人尤其是初学者并不会经常使用他。 在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。  简介RACCommand 与 RACSignal 等元素是不同的，RACComma">
<meta name="twitter:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACCommand.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huangzhifei.github.io/2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/"/>





  <title>RACCommand的用法 | EricHuang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EricHuang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每一个不码代码的日子，都是对生命的辜负!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home // 首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user // 关于"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags // 标签"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th // 分类"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive // 归档"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangzhifei.github.io/2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/avatar-photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EricHuang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RACCommand的用法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T23:29:54+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RAC/" itemprop="url" rel="index">
                    <span itemprop="name">RAC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><p>RACCommand 在 ReactiveObjc 中是比较复杂的类，对于大多数人尤其是初学者并不会经常使用他。</p>
<p>在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACCommand.png" alt=""></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RACCommand 与 RACSignal 等元素是不同的，RACCommand 并不表示数据流，可以看他的继承关系，他是直接继承自 NSObject，但是看他提供的 API，他是可以用来创建和订阅用于响应某些事件的信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface RACCommand&lt;__contravariant InputType, __covariant ValueType&gt; : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>他是一个用于管理 RACSignal 的创建与订阅的类。</p>
<p>在 ReactiveObjc 中对 RACCommand 有这样一段直白的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A command,represented by the RACCommand class,creates and subscribes to a signal in response to some action.</span><br><span class="line"></span><br><span class="line">This makes it easy to perform side-effecting(副作用) work as the user interacts with the app.</span><br></pre></td></tr></table></figure>
<p>在用于与 UIKit 组件进行交互或执行包含副作用的操作时，RACCommand 能够帮助我们更快的处理并且响应任务，减少编码以及工程的复杂度。</p>
<h3 id="初始化和执行"><a href="#初始化和执行" class="headerlink" title="初始化和执行"></a>初始化和执行</h3><p>在 - (instancetype)initWithSignalBlock: 方法的签名上，你可以看到在每次 RACCommand 初始化时都会传入一个类型为 (RACSignal<valuetype> * (^)(InputType _Nullable input))signalBlock: </valuetype></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br></pre></td></tr></table></figure>
<p>输入为 InputType 返回值为 RACSignal<valuetype> *, 而 InputType 也就是在调用 - excute: 方法传入的对象：</valuetype></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(nullable InputType)input;</span><br></pre></td></tr></table></figure>
<p>这就是 RACCommand 将外部变量（或副作用）传入 ReactiveObjc 内部的方法，你可以理解为 RACCommand 将外部的变量 InputType 转换成了使用 RACSignal 包裹的 ValueType 对象。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execute-For-RACCommand.png" alt=""></p>
<p>我们以下面的代码为例子，先来看一下 RACCommand 是如何工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) &#123;</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        NSInteger integer = [input integerValue];</span><br><span class="line">        for (NSInteger i = 0; i &lt; integer; i++) &#123;</span><br><span class="line">            [subscriber sendNext:@(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;command: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[command execute:@1];</span><br><span class="line"></span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.1</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@2];</span><br><span class="line">                                    &#125;];</span><br><span class="line">                                    </span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.2</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@3];</span><br><span class="line">                                    &#125;];</span><br></pre></td></tr></table></figure>
<p>上面的代码打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command: 0</span><br><span class="line">command: 0</span><br><span class="line">command: 1</span><br><span class="line">command: 0</span><br><span class="line">command: 1</span><br><span class="line">command: 2</span><br></pre></td></tr></table></figure>
<p>每次 executionSignals 中发送了新的信号时，switchToLatest 方法返回的信号都会订阅这个最新的信号，这里也就保证了每次都会打印出最新的信号中的值。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Multiple-Executes.png" alt=""></p>
<p>在上面的代码中还有最后一个问题，为什么要使用 RACScheduler.mainThreadScheduler 延迟调用之后的 - execute: 方法？</p>
<p>由于在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次的操作，否则就会返回错误信号 RACErrorSignal，这些错误可以通过订阅 command.errors 获取。</p>
<p>所以如果你使用如下的方式执行几次 - execute: 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[command execute:@1];</span><br><span class="line">[command execute:@2];</span><br><span class="line">[command execute:@3];</span><br></pre></td></tr></table></figure>
<p>最终就只打印 command: 0</p>
<h3 id="最重要的内部“信号”"><a href="#最重要的内部“信号”" class="headerlink" title="最重要的内部“信号”"></a>最重要的内部“信号”</h3><p>RACCommand 中最重要的内部信号就是 addedExecutionSignalsSubject:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) RACSubject *addedExecutionSignalsSubject;</span><br></pre></td></tr></table></figure>
<p>这个 RACSubject 对象通过各种操作衍生了几乎所有 RACCommand 中的其他信号。</p>
<p>既然 addedExecutionSignalsSubject 是一个 RACSubject，它不能在创建时预设好对订阅者发送的消息，它会在哪里接受数据并推送给订阅者呢？答案就在 -execute: 方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)execute:(id)input &#123;</span><br><span class="line">	BOOL enabled = [[self.immediateEnabled first] boolValue];</span><br><span class="line">	if (!enabled) &#123;</span><br><span class="line">		NSError *error = [NSError errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@&#123;</span><br><span class="line">			NSLocalizedDescriptionKey: NSLocalizedString(@&quot;The command is disabled and cannot be executed&quot;, nil),</span><br><span class="line">			RACUnderlyingCommandErrorKey: self</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		return [RACSignal error:error];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RACSignal *signal = self.signalBlock(input);</span><br><span class="line">	RACMulticastConnection *connection = [[signal</span><br><span class="line">		subscribeOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">		multicast:[RACReplaySubject subject]];</span><br><span class="line">	</span><br><span class="line">	[self.addedExecutionSignalsSubject sendNext:connection.signal];</span><br><span class="line"></span><br><span class="line">	[connection connect];</span><br><span class="line">	return [connection.signal setNameWithFormat:@&quot;%@ -execute: %@&quot;, self, RACDescription(input)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中这里你也能看到连续几次执行 -execute: 方法不能成功的原因：每次执行这个方法时，都会从另一个信号 immediateEnabled 中读取是否能执行当前命令的 BOOL 值，如果不可以执行的话，就直接返回 RACErrorSignal。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execute-on-RACCommand.png" alt=""></p>
<ul>
<li>execute: 方法是唯一一个为 addedExecutionSignalsSubject 生产信息的方法。</li>
</ul>
<p>在执行 signalBlock 返回一个 RACSignal 之后，会将当前信号包装成一个 RACMulticastConnection，然后调用 -sendNext: 方法发送到 addedExecutionSignalsSubject 上，执行 -connect 方法订阅原有的信号，最后返回。</p>
<h3 id="复杂的初始化"><a href="#复杂的初始化" class="headerlink" title="复杂的初始化"></a>复杂的初始化</h3><p>由于 RACCommand 在初始化方法中初始化了七个高阶信号，它的实现非常复杂，这里先介绍其中的 immediateExecuting 和 moreExecutionsAllowed 两个临时信号。</p>
<h4 id="immediateExecuting-表示当前有操作执行的信号"><a href="#immediateExecuting-表示当前有操作执行的信号" class="headerlink" title="immediateExecuting 表示当前有操作执行的信号"></a>immediateExecuting 表示当前有操作执行的信号</h4><p>我们看 immediateExecuting 信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *immediateExecuting = [[[[self.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        return [[[signal</span><br><span class="line">            catchTo:[RACSignal empty]]</span><br><span class="line">            then:^&#123;</span><br><span class="line">                return [RACSignal return:@-1];</span><br><span class="line">            &#125;]</span><br><span class="line">            startWith:@1];</span><br><span class="line">    &#125;]</span><br><span class="line">    scanWithStart:@0 reduce:^(NSNumber *running, NSNumber *next) &#123;</span><br><span class="line">        return @(running.integerValue + next.integerValue);</span><br><span class="line">    &#125;]</span><br><span class="line">    map:^(NSNumber *count) &#123;</span><br><span class="line">        return @(count.integerValue &gt; 0);</span><br><span class="line">    &#125;]</span><br><span class="line">    startWith:@NO];</span><br></pre></td></tr></table></figure>
<p>immediateExecuting 是一个用于表示当前是否有任务执行的信号，如果输入的 addedExecutionSignalsSubject 等价于以下的信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:[RACSignal error:[NSError errorWithDomain:@&quot;Error&quot; code:1 userInfo:nil]]];</span><br><span class="line">    [subscriber sendNext:[RACSignal return:@1]];</span><br><span class="line">    [subscriber sendNext:[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [RACScheduler.mainThreadScheduler afterDelay:1</span><br><span class="line">                                            schedule:^</span><br><span class="line">         &#123;</span><br><span class="line">             [subscriber sendCompleted];</span><br><span class="line">         &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;]];</span><br><span class="line">    [subscriber sendNext:[RACSignal return:@3]];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>那么最后生成的高阶信号 immediateExecuting 如下：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/immediateExecuting-Signal-in-RACCommand.png" alt=""></p>
<ol>
<li>-catchTo: 将所有的错误转换成 RACEmptySignal 信号</li>
<li>-flattenMap: 将每一个信号的开始和结束的时间点转换成 1 和 -1 两个信号</li>
<li>-scanWithStart:reduce: 从 0 开始累加原有的信号</li>
<li>-map: 将大于 1 的信号转换为 @yes</li>
<li>-startWith: 在信号序列最前面加入 @NO，表示在最开始时，没有任何动作在执行</li>
</ol>
<p>immediateExecuting 使用几个 RACSignal 的操作成功将原有的信号流转换成了表示是否有操作执行的信号流。</p>
<h4 id="moreExecutionsAllowed-表示是否允许更多操作执行的信号"><a href="#moreExecutionsAllowed-表示是否允许更多操作执行的信号" class="headerlink" title="moreExecutionsAllowed 表示是否允许更多操作执行的信号"></a>moreExecutionsAllowed 表示是否允许更多操作执行的信号</h4><p>相比于 immediateExecuting 信号的复杂，moreExecutionsAllowed 就简单多了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">    if:[self.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">    then:[RACSignal return:@YES]</span><br><span class="line">    else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure>
<p>因为文章中不准备介绍与并发执行有关的内容，所以这里的 then 语句永远不会执行，既然 RACCommand 不支持并行操作，那么这段代码就非常好理解了，当前 RACCommand 能否执行操作就是 immediateExecuting 取反：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/MoreExecutionAllowed-Signal.png" alt=""></p>
<p>到此这两个高阶操作就介绍完了。</p>
<h3 id="RACCommand-接口中的高阶信号"><a href="#RACCommand-接口中的高阶信号" class="headerlink" title="RACCommand 接口中的高阶信号"></a>RACCommand 接口中的高阶信号</h3><p>每一个 RACCommand 对象中都管理着多个信号，它在接口中暴露出四个重要信号：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCommand-Interface.png" alt=""></p>
<h4 id="executionSignals"><a href="#executionSignals" class="headerlink" title="executionSignals"></a>executionSignals</h4><p><code>executionSignals</code> 是 <code>RACCommand</code> 中最重要的信号；<br>从类型来看，它是一个包含信号的信号，在每次执行 <code>-execute:</code> 方法时，最终都会向 <code>executionSignals</code> 中传入一个最新的信号。</p>
<p>虽然它最重要，但是 <code>executionSignals</code> 是这个几个高阶信号中实现最简单的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_executionSignals = [[[self.addedExecutionSignalsSubject</span><br><span class="line">    map:^(RACSignal *signal) &#123;</span><br><span class="line">        return [signal catchTo:[RACSignal empty]];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    setNameWithFormat:@&quot;%@ -executionSignals&quot;, self];</span><br></pre></td></tr></table></figure>
<p>它只是将信号中的所有的错误 NSError 转换成了 RACEmptySignal 对象，并派发到主线程上。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execution-Signals.png" alt=""></p>
<p>如果你只订阅了 executionSignals，那么其实你不会收到任何的错误，所有的错误都会以 -sendNext: 的形式被发送到 errors 信号中。</p>
<h4 id="executing"><a href="#executing" class="headerlink" title="executing"></a>executing</h4><p><code>executing</code> 是一个表示当前是否有任务执行的信号，这个信号使用了在上一节中介绍的临时变量作为数据源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_executing = [[[[[immediateExecuting</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    startWith:@NO]</span><br><span class="line">    distinctUntilChanged]</span><br><span class="line">    replayLast]</span><br><span class="line">    setNameWithFormat:@&quot;%@ -executing&quot;, self];</span><br></pre></td></tr></table></figure>
<p>这里对 immediateExecuting 的变换还是非常容易理解的：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Executing-Signal.png" alt=""></p>
<p>最后的 <code>replayLast</code> 方法将原有的信号变成了容量为 <code>1</code> 的 <code>RACReplaySubject</code> 对象，这样在每次有订阅者订阅 <code>executing</code> 信号时，都只会发送最新的状态，因为订阅者并不关心过去的 <code>executing</code> 的值。</p>
<h4 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h4><p><code>enabled</code> 信号流表示当前的命令是否可以再次被执行，也就是 <code>-execute:</code> 方法能否可以成功执行新的任务；该信号流依赖于另一个私有信号 <code>immediateEnabled：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *enabledSignal = [RACSignal return:@YES];</span><br><span class="line"></span><br><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">    combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">    and]</span><br><span class="line">    takeUntil:self.rac_willDeallocSignal]</span><br><span class="line">    replayLast];</span><br></pre></td></tr></table></figure>
<p>虽然这个信号的实现比较简单，不过它同时与三个信号有关，<code>enabledSignal</code>、<code>moreExecutionsAllowed</code> 以及 <code>rac_willDeallocSignal：</code></p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Immediate-Enabled-Signal.png" alt=""></p>
<p>虽然图中没有体现出方法 <code>-takeUntil:self.rac_willDeallocSignal</code> 的执行，不过你需要知道，这个信号在当前 <code>RACCommand</code> 执行 <code>dealloc</code> 之后就不会再发出任何消息了。</p>
<p>而 <code>enabled</code> 信号其实与 <code>immediateEnabled</code> 相差无几：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_enabled = [[[[[self.immediateEnabled</span><br><span class="line">    take:1]</span><br><span class="line">    concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">    distinctUntilChanged]</span><br><span class="line">    replayLast]</span><br><span class="line">    setNameWithFormat:@&quot;%@ -enabled&quot;, self];</span><br></pre></td></tr></table></figure>
<p>从名字你可以看出来，<code>immediateEnabled</code> 在每次原信号发送消息时都会重新计算，而 <code>enabled</code> 调用了 <code>-distinctUntilChanged</code> 方法，所以如果连续几次值相同就不会再次发送任何消息。</p>
<p>除了调用 <code>-distinctUntilChanged</code> 的区别之外，你可以看到 <code>enabled</code> 信号在最开始调用了 <code>-take:</code> 和 <code>-concat:</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[self.immediateEnabled</span><br><span class="line">		take:1]</span><br><span class="line">		concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]];</span><br></pre></td></tr></table></figure>
<p>虽然序列并没有任何的变化，但是在这种情况下，<code>enabled</code> 信号流中的第一个值会在订阅线程上到达，剩下的所有的值都会在主线程上派发；如果你知道，在一般情况下，我们都会使用 <code>enabled</code> 信号来控制 <code>UI</code> 的改变（例如 <code>UIButton</code>），相信你就会明白这么做的理由了。</p>
<h4 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h4><p>错误信号是 <code>RACCommand</code> 中比较简单的信号；为了保证 <code>RACCommand</code> 对此执行 <code>-execute:</code> 方法也可以继续运行，我们只能将所有的错误以其它的形式发送到 <code>errors</code> 信号中，防止向 <code>executionSignals</code> 发送错误信号后，<code>executionSignals</code> 信号就会中止的问题。</p>
<p>我们使用如下的方式创建 errors 信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACMulticastConnection *errorsConnection = [[[self.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        return [[signal</span><br><span class="line">            ignoreValues]</span><br><span class="line">            catch:^(NSError *error) &#123;</span><br><span class="line">                return [RACSignal return:error];</span><br><span class="line">            &#125;];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:@&quot;%@ -errors&quot;, self];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure>
<p>信号的创建过程是把所有的错误消息重新打包成 <code>RACErrorSignal</code> 并在主线程上进行派发：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Errors-Signals.png" alt=""></p>
<p>使用者只需要调用 <code>-subscribeNext:</code> 就可以从这个信号中获取所有执行过程中发生的错误。</p>
<h3 id="RACCommand-的使用"><a href="#RACCommand-的使用" class="headerlink" title="RACCommand 的使用"></a>RACCommand 的使用</h3><p><code>RACCommand</code> 非常适合封装网络请求，我们可以使用下面的代码封装一个网络请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) &#123;</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        NSURL *url = [NSURL URLWithString:@&quot;http://localhost:3000&quot;];</span><br><span class="line">        AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:url];</span><br><span class="line">        NSString *URLString = [NSString stringWithFormat:@&quot;/api/products/%@&quot;, input ?: @1];</span><br><span class="line">        NSURLSessionDataTask *task = [manager GET:URLString parameters:nil progress:nil</span><br><span class="line">             success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;</span><br><span class="line">                 [subscriber sendNext:responseObject];</span><br><span class="line">                 [subscriber sendCompleted];</span><br><span class="line">             &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">                 [subscriber sendError:error];</span><br><span class="line">             &#125;];</span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            [task cancel];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>上面的 <code>RACCommand</code> 对象可以通过 <code>-execute:</code> 方法执行，同时，订阅 <code>executionSignals</code> 以及 <code>errors</code> 来获取网络请求的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[command.errors subscribeNext:^(NSError * _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[command execute:@1];</span><br></pre></td></tr></table></figure>
<p>向方法 <code>-execute:</code> 中传入了 <code>@1</code> 对象，从服务器中获取了 <code>id = 1</code> 的商品对象；当然，我们也可以传入不同的 <code>id</code> 来获取不同的模型，所有的网络请求以及 <code>JSON</code> 转换模型的逻辑都可以封装到这个 <code>RACCommand</code> 的 <code>block</code> 中，外界只是传入一个 <code>id</code>，最后就从 <code>executionSignals</code> 信号中获取了开箱即用的对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>RACCommand</code> 能够优雅地将包含副作用的操作和与副作用无关的操作分隔起来；整个 <code>RACCommand</code> 相当于一个黑箱，从 <code>-execute:</code> 方法中获得输入，最后以向信号发送消息的方式，向订阅者推送结果。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCommand-Side-Effect.png" alt=""></p>
<p>这种执行任务的方式就像是一个函数，根据输入的不同，有着不同的输出，非常适合与 <code>UI</code>、网络操作的相关的任务，这也是 <code>RACCommand</code> 的设计的优雅之处。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RAC/" rel="tag"># RAC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/17/Objective-C/ReactiveObjc/RACScheduler的用法/" rel="next" title="RACScheduler的用法">
                <i class="fa fa-chevron-left"></i> RACScheduler的用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/20/Objective-C/ReactiveObjc/RACSubject的用法/" rel="prev" title="RACSubject的用法">
                RACSubject的用法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/avatar-photo.png"
                alt="Eric Huang" />
            
              <p class="site-author-name" itemprop="name">Eric Huang</p>
              <p class="site-description motion-element" itemprop="description">~ 生活不止苟且，还有诗和远方，迎着朝阳前进，看风与雪。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/huangzhifei" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/chongzizizizizizi/home?leftnav=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RACCommand"><span class="nav-number">1.</span> <span class="nav-text">RACCommand</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化和执行"><span class="nav-number">1.2.</span> <span class="nav-text">初始化和执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最重要的内部“信号”"><span class="nav-number">1.3.</span> <span class="nav-text">最重要的内部“信号”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂的初始化"><span class="nav-number">1.4.</span> <span class="nav-text">复杂的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#immediateExecuting-表示当前有操作执行的信号"><span class="nav-number">1.4.1.</span> <span class="nav-text">immediateExecuting 表示当前有操作执行的信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#moreExecutionsAllowed-表示是否允许更多操作执行的信号"><span class="nav-number">1.4.2.</span> <span class="nav-text">moreExecutionsAllowed 表示是否允许更多操作执行的信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RACCommand-接口中的高阶信号"><span class="nav-number">1.5.</span> <span class="nav-text">RACCommand 接口中的高阶信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#executionSignals"><span class="nav-number">1.5.1.</span> <span class="nav-text">executionSignals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#executing"><span class="nav-number">1.5.2.</span> <span class="nav-text">executing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enabled"><span class="nav-number">1.5.3.</span> <span class="nav-text">enabled</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#errors"><span class="nav-number">1.5.4.</span> <span class="nav-text">errors</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RACCommand-的使用"><span class="nav-number">1.6.</span> <span class="nav-text">RACCommand 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Huang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://huangzhifei.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://huangzhifei.github.io/2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/';
          this.page.identifier = '2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/';
          this.page.title = 'RACCommand的用法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://huangzhifei.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
