<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="RAC," />





  <link rel="alternate" href="/atom.xml" title="EricHuang's blog" type="application/atom+xml" />






<meta name="description" content="ReactiveCocoa 与信号RAC 将原有的各种设计模式，包括代理、Target-Action、通知中心以观察者模式各种各种『输入』，都抽象成信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。 在 RAC 中最重要的信号，也就是 RACSignal 对象是这一篇文章的核心，文章主要会介绍下面的代码片段： 1234567891011RACSignal">
<meta name="keywords" content="RAC">
<meta property="og:type" content="article">
<meta property="og:title" content="RACSignal的用法">
<meta property="og:url" content="https://huangzhifei.github.io/2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/index.html">
<meta property="og:site_name" content="EricHuang&#39;s blog">
<meta property="og:description" content="ReactiveCocoa 与信号RAC 将原有的各种设计模式，包括代理、Target-Action、通知中心以观察者模式各种各种『输入』，都抽象成信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。 在 RAC 中最重要的信号，也就是 RACSignal 对象是这一篇文章的核心，文章主要会介绍下面的代码片段： 1234567891011RACSignal">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Hierachy.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACSignal.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACStream-AbstractMethod.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACStream-Operation.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Return.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Bind.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Before-After-Bind-RACSignal.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Before-After-Bind-RACSignal-Complicated.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subclasses.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Instantiate-Object.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subcribe-Process.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subscribe-Methods.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Principle-of-Subscribing-Signals.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subcription-Messages-Sending.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACDisposable-And-Subclasses.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACDisposable.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCompoundDisposable.png">
<meta property="og:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Bind-Disposable.png">
<meta property="og:updated_time" content="2020-01-05T02:55:03.370Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RACSignal的用法">
<meta name="twitter:description" content="ReactiveCocoa 与信号RAC 将原有的各种设计模式，包括代理、Target-Action、通知中心以观察者模式各种各种『输入』，都抽象成信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。 在 RAC 中最重要的信号，也就是 RACSignal 对象是这一篇文章的核心，文章主要会介绍下面的代码片段： 1234567891011RACSignal">
<meta name="twitter:image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Hierachy.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huangzhifei.github.io/2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/"/>





  <title>RACSignal的用法 | EricHuang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EricHuang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每一个不码代码的日子，都是对生命的辜负!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home // 首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user // 关于"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags // 标签"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th // 分类"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive // 归档"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangzhifei.github.io/2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/avatar-photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EricHuang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RACSignal的用法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T22:48:42+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RAC/" itemprop="url" rel="index">
                    <span itemprop="name">RAC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="ReactiveCocoa-与信号"><a href="#ReactiveCocoa-与信号" class="headerlink" title="ReactiveCocoa 与信号"></a>ReactiveCocoa 与信号</h2><p><code>RAC</code> 将原有的各种设计模式，包括代理、<code>Target-Action</code>、通知中心以观察者模式各种各种『输入』，都抽象成信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。</p>
<p>在 <code>RAC</code> 中最重要的信号，也就是 <code>RACSignal</code> 对象是这一篇文章的核心，文章主要会介绍下面的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;dispose&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在上述代码执行时，会在控制台中打印出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">dispose</span><br></pre></td></tr></table></figure>
<p>代码片段基本都是围绕 <code>RACSignal</code> 类进行的，接下来主要分成以下几点来展开：</p>
<ul>
<li>简单了解 <code>RACSignal</code></li>
<li>信号的创建</li>
<li>信号的订阅与发送</li>
<li>订阅的回收过程</li>
</ul>
<h2 id="RACSignal-简介"><a href="#RACSignal-简介" class="headerlink" title="RACSignal 简介"></a>RACSignal 简介</h2><p><code>RACSignal</code> 其实是抽象类 <code>RACStream</code> 的子类，在整个 <code>RAC</code> 工程中有另一个类 <code>RACSequence</code> 也继承自抽象类 <code>RACStream</code>：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Hierachy.png" alt=""></p>
<p><code>RACSignal</code> 是 <code>RAC</code> 的核心，他可以简单理解为一连串的状态:</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACSignal.png" alt=""></p>
<p>在状态改变时，对应的订阅者 RACSubscriber    就会收到通知执行相应的指令，在 <code>RAC</code> 的世界中所有的消息都是通过信号的方式来传递的，原有的设计模式都会简化为一种模型。</p>
<h2 id="RACStream"><a href="#RACStream" class="headerlink" title="RACStream"></a>RACStream</h2><p><code>RACStream</code> 作为抽象类本身不提供方法的实现，其实现内部原生提供的而方法都是抽象方法，会在调用时直接抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (__kindof RACStream *)empty &#123;</span><br><span class="line">	NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];</span><br><span class="line">	@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;</span><br><span class="line">+ (__kindof RACStream *)return:(id)value;</span><br><span class="line">- (__kindof RACStream *)concat:(RACStream *)stream;</span><br><span class="line">- (__kindof RACStream *)zipWith:(RACStream *)stream;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACStream-AbstractMethod.png" alt=""></p>
<p>上面的这些抽象方法都需要子类覆写，不过 <code>RACStream</code> 在 <code>Operations</code> 分类中使用上面的抽象方法提供了丰富的内容，比如说 <code>-flattenMap:</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block &#123;</span><br><span class="line">	Class class = self.class;</span><br><span class="line"></span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		return ^(id value, BOOL *stop) &#123;</span><br><span class="line">			id stream = block(value) ?: [class empty];</span><br><span class="line">			NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);</span><br><span class="line"></span><br><span class="line">			return stream;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他方法比如 <code>-skip:</code>、<code>-take:</code>、<code>-ignore：</code> 等等实例方法都构建在这些抽象方法之上，只要子类覆写了所有抽象方法就能自动获得所有的 <code>Operation</code> 分类中的方法。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACStream-Operation.png" alt=""></p>
<h2 id="RACSignal-细说"><a href="#RACSignal-细说" class="headerlink" title="RACSignal 细说"></a>RACSignal 细说</h2><p><code>RAC</code> 框架借鉴了很多平台的概念，就比如 <code>RACStream</code> 的抽象方法 <code>+return:</code> 和 <code>-bind:</code><br>首先我们来看一下 <code>+return:</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">	return [RACReturnSignal return:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改方法接受一个 <code>NSObject</code> 对象，并返回一个 <code>RACSignal</code> 的实例，它会将一个 <code>Foundation</code> 世界的对象 <code>NSObject</code> 转换成 <code>RAC</code> 中的 <code>RACSignal</code></p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Return.png" alt=""></p>
<p>而 <code>RACReturnSignal</code> 也仅仅是把 <code>NSObject</code> 对象包装一下，并没有做什么复杂的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">	RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">	signal-&gt;_value = value;</span><br><span class="line">	return signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 <code>-bind:</code> 方法的实现相比之下就十分复杂了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        return [self subscribeNext:^(id x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            if (signal != nil) &#123;</span><br><span class="line">                [signal subscribeNext:^(id x) &#123;</span><br><span class="line">                    [subscriber sendNext:x];</span><br><span class="line">                &#125; error:^(NSError *error) &#123;</span><br><span class="line">                    [subscriber sendError:error];</span><br><span class="line">                &#125; completed:^&#123;</span><br><span class="line">                    [subscriber sendCompleted];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            if (signal == nil || stop) &#123;</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; error:^(NSError *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>上面对 bind 方法进行一些省略，省掉了对 RACDisposable 的处理。</code></p>
<p><code>-bind:</code> 方法会在原信号每次发出消息时，都执行 <code>RACSignalBindBlock</code> 对原有的信号中的消息进行变换，生成一个新的信号：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Bind.png" alt=""></p>
<p><code>在原有的 RACSignal 对象上调用 -bind：方法传入 RACSignalBindBlock，图示中的右侧就是具体的执行过程，原信号在变换之后变成了新的蓝色的 RACSignal 对象。</code></p>
<p><code>RACSignalBindBlock</code> 可以简单理解为一个接受 <code>NSObject</code> 对象返回 <code>RACSignal</code> 对象的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef RACSignal * _Nullable (^RACSignalBindBlock)(id _Nullable value, BOOL *stop);</span><br></pre></td></tr></table></figure>
<p>其函数签名可以理解为 <code>id -&gt; RACSignal</code>，然而这种函数是无法直接对 <code>RACSignal</code> 对象进行变换的；不过通过 <code>-bind:</code> 方法就可以使用这种函数操作 <code>RACSignal</code>，其实现如下：</p>
<ol>
<li>将 <code>RACSignal</code> 对象『解包』出 <code>NSObject</code> 对象；</li>
<li>将 <code>NSObject</code> 传入 <code>RACSignalBindBlock</code> 返回 <code>RACSignal</code>。</li>
</ol>
<p>如果不考虑 <code>RACSignal</code> 会发出错误或者完成信号时，<code>-bind：</code>可以简化为下面简单的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        return [self subscribeNext:^(id x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            [bindingBlock(x, &amp;stop) subscribeNext:^(id x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>-subscribeNext:</code> 方法订阅当前信号，将信号中的状态解包，然后将原信号中的状态传入 <code>bindingBlock</code> 中并订阅返回的新的信号，将生成的新状态 <code>x</code> 传回原信号的订阅者。</p>
<p>这里通过两个简单的例子来了解 <code>-bind：</code>方法的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendNext:@3];</span><br><span class="line">    [subscriber sendNext:@4];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line">        return [RACSignal return:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;signal: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;bindSignal: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>上面的代码直接使用了 <code>+return：</code>方法将 <code>value</code> 打包成了 <code>RACSignal *</code> 对象：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Before-After-Bind-RACSignal.png" alt=""></p>
<p><code>在 BindSignal 中的每一个数字其实都是由一个 RACSignal 包裹的，这里没有画出，在下一个例子中，可以清晰的看到他们的区别。</code></p>
<p>上图简要展示了变化前后的信号中包含的状态，在运行上述代码时，会在终端中打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">signal: 1</span><br><span class="line">signal: 2</span><br><span class="line">signal: 3</span><br><span class="line">signal: 4</span><br><span class="line">bindSignal: 1</span><br><span class="line">bindSignal: 4</span><br><span class="line">bindSignal: 9</span><br><span class="line">bindSignal: 16</span><br></pre></td></tr></table></figure>
<p>这是一个最简单的例子，直接使用 <code>-return:</code> 打包 <code>NSObject</code> 返回一个 <code>RACSignal</code>，接下来用一个更复杂的例子来帮助我们更好的了解 <code>-bind:</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        NSNumber *returnValue = @(value.integerValue * value.integerValue);</span><br><span class="line">        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; value.integerValue; i++) [subscriber sendNext:returnValue];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>下图相比上面例子中的图片更能精确的表现出 <code>-bind：</code>方法都做了什么：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Before-After-Bind-RACSignal-Complicated.png" alt=""></p>
<p>信号中原有的状态经过 <code>-bind:</code> 方法中传入 <code>RACSignalBindBlock</code> 的处理实际上返回了多个 <code>RACSignal</code>。</p>
<p>在源代码的注释中清楚地写出了方法的实现过程：</p>
<ol>
<li>订阅原信号中的值；</li>
<li>将原信号发出的值传入 <code>RACSignalBindBlock</code> 进行转换；</li>
<li>如果 <code>RACSignalBindBlock</code> 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 <code>subscriber</code>；</li>
<li>如果 <code>RACSignalBindBlock</code> 请求终止信号就会向原信号发出 <code>-sendCompleted</code> 消息；</li>
<li>当所有信号都完成时，会向订阅者发送 <code>-sendCompleted</code>；</li>
<li>无论何时，如果信号发出错误，都会向订阅者发送 <code>-sendError:</code> 消息。</li>
</ol>
<h2 id="信号的创建"><a href="#信号的创建" class="headerlink" title="信号的创建"></a>信号的创建</h2><p>信号的创建过程十分简单，<code>-createSignal:</code> 是推荐的创建信号的方法，方法其实只做了一次转发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">	return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">	RACDynamicSignal *signal = [[self alloc] init];</span><br><span class="line">	signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line">	return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改方法其实只是创建了一个 <code>RACDynamicSignal</code> 实例并保存了传入的 <code>didSubscribe</code> 代码块，在每次有订阅者订阅当前信号时，都会执行一遍，向订阅者发送消息。</p>
<h2 id="RACSignal-类簇"><a href="#RACSignal-类簇" class="headerlink" title="RACSignal 类簇"></a>RACSignal 类簇</h2><p>虽然 <code>-createSignal:</code> 的方法签名上返回的是 <code>RACSignal</code> 对象的实例，但是实际上这里返回的是 <code>RACDynamicSignal</code>，也就是 <code>RACSignal</code> 的子类；同样，在 <code>ReactiveCocoa</code> 中也有很多其他的 <code>RACSignal</code> 子类。</p>
<p>使用类簇的方式设计的 <code>RACSignal</code> 在创建实例时可能会返回 <code>RACDynamicSignal</code>、<code>RACEmptySignal</code>、<code>RACErrorSignal</code> 和 <code>RACReturnSignal</code> 对象：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subclasses.png" alt=""></p>
<p>其实这几种子类并没有对原有的 <code>RACSignal</code> 做出太大的改变，它们的创建过程也不是特别复杂，只需要调用 <code>RACSignal</code> 不同的类方法：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Instantiate-Object.png" alt=""></p>
<p><code>RACSignal</code> 只是起到了一个代理的作用，最后的实现过程还是会指向对应的子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACSignal *)error:(NSError *)error &#123;</span><br><span class="line">	return [RACErrorSignal error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)empty &#123;</span><br><span class="line">	return [RACEmptySignal empty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">	return [RACReturnSignal return:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>RACReturnSignal</code> 的创建过程为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">	RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">	signal-&gt;_value = value;</span><br><span class="line">	return signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个信号的创建过程和 <code>RACDynamicSignal</code> 的初始化过程一样，都非常简单；只是将传入的 <code>value</code> 简单保存一下，在有其他订阅者 <code>-subscribe:</code> 时，向订阅者发送 <code>value：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	return [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">		[subscriber sendNext:self.value];</span><br><span class="line">		[subscriber sendCompleted];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RACEmptySignal</code> 和 <code>RACErrorSignal</code> 的创建过程也异常的简单，只是对传入的数据进行简单的存储，然后在订阅时发送出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// RACEmptySignal</span><br><span class="line">+ (RACSignal *)empty &#123;</span><br><span class="line">	return [[[self alloc] init] setNameWithFormat:@&quot;+empty&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	return [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">		[subscriber sendCompleted];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RACErrorSignal</span><br><span class="line">+ (RACSignal *)error:(NSError *)error &#123;</span><br><span class="line">	RACErrorSignal *signal = [[self alloc] init];</span><br><span class="line">	signal-&gt;_error = error;</span><br><span class="line">	return signal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	return [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">		[subscriber sendError:self.error];</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个创建过程的唯一区别就是一个发送的是『空值』，另一个是 <code>NSError</code> 对象。</p>
<h2 id="信号的订阅与信息的发送"><a href="#信号的订阅与信息的发送" class="headerlink" title="信号的订阅与信息的发送"></a>信号的订阅与信息的发送</h2><p><code>ReactiveCocoa</code> 中信号的订阅与信息的发送过程主要是由 <code>RACSubscriber</code> 类来处理的，而这也是信号的处理过程中最重要的一部分，这一小节会先分析整个工作流程，之后会深入代码的实现。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subcribe-Process.png" alt=""></p>
<p>在信号创建之后调用 <code>-subscribeNext:</code> 方法返回一个 <code>RACDisposable</code>，然而这不是这一流程关心的重点，在订阅过程中生成了一个 <code>RACSubscriber</code> 对象，向这个对象发送消息 <code>-sendNext:</code> 时，就会向所有的订阅者发送消息。</p>
<h3 id="信号的订阅"><a href="#信号的订阅" class="headerlink" title="信号的订阅"></a>信号的订阅</h3><p>信号的订阅与 <code>-subscribe:</code> 开头的一系列方法有关：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subscribe-Methods.png" alt=""></p>
<p>订阅者可以选择自己想要感兴趣的信息类型 <code>next/error/completed</code> 进行关注，并在对应的信息发生时调用 <code>block</code> 进行处理回调。</p>
<p>所有的方法其实只是对 <code>nextBlock</code>、<code>completedBlock</code> 以及 <code>errorBlock</code> 的组合，这里以其中最长的 <code>-subscribeNext:error:completed:</code> 方法的实现为例（也只需要介绍这一个方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock &#123;</span><br><span class="line">	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line">	return [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到了传入的 <code>block</code> 之后，使用 <code>+subscriberWithNext:error:completed:</code> 初始化一个 <code>RACSubscriber</code> 对象的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line">	RACSubscriber *subscriber = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">	subscriber-&gt;_next = [next copy];</span><br><span class="line">	subscriber-&gt;_error = [error copy];</span><br><span class="line">	subscriber-&gt;_completed = [completed copy];</span><br><span class="line"></span><br><span class="line">	return subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到这个对象之后，调用 <code>RACSignal</code> 的 <code>-subscribe:</code> 方法传入订阅者对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	NSCAssert(NO, @&quot;This method must be overridden by subclasses&quot;);</span><br><span class="line">	return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RACSignal</code> 类中其实并没有实现这个实例方法，需要在上文提到的四个子类对这个方法进行覆写，这里仅分析 <code>RACDynamicSignal</code> 中的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">        RACDisposable *innerDisposable = self.didSubscribe(subscriber);</span><br><span class="line">        [disposable addDisposable:innerDisposable];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [disposable addDisposable:schedulingDisposable];</span><br><span class="line">    </span><br><span class="line">    return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RACPassthroughSubscriber</code> 就像它的名字一样，只是对上面创建的订阅者对象进行简单的包装，将所有的消息转发给内部的 <code>innerSubscriber</code>，也就是传入的 <code>RACSubscriber</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithSubscriber:(id&lt;RACSubscriber&gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable &#123;</span><br><span class="line">	self = [super init];</span><br><span class="line"></span><br><span class="line">	_innerSubscriber = subscriber;</span><br><span class="line">	_signal = signal;</span><br><span class="line">	_disposable = disposable;</span><br><span class="line"></span><br><span class="line">	[self.innerSubscriber didSubscribeWithDisposable:self.disposable];</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接简化 <code>-subscribe:</code> 方法的实现，你可以看到一个看起来极为敷衍的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    return self.didSubscribe(subscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法只是执行了在创建信号时传入的 <code>RACSignalBindBlock</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;dispose&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>总而言之，信号的订阅过程就是初始化 <code>RACSubscriber</code> 对象，然后执行 <code>didSubscribe</code> 代码块的过程。</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Principle-of-Subscribing-Signals.png" alt=""></p>
<h3 id="信息的发送"><a href="#信息的发送" class="headerlink" title="信息的发送"></a>信息的发送</h3><p>在 <code>RACSignalBindBlock</code> 中，订阅者可以根据自己的兴趣选择自己想要订阅哪种消息；我们也可以按需发送三种消息：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subcription-Messages-Sending.png" alt=""></p>
<p>而现在只需要简单看一下这三个方法的实现，就能够明白信息的发送过程了（真是没啥好说的，不过为了凑字数完整性）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">	@synchronized (self) &#123;</span><br><span class="line">		void (^nextBlock)(id) = [self.next copy];</span><br><span class="line">		if (nextBlock == nil) return;</span><br><span class="line"></span><br><span class="line">		nextBlock(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>-sendNext:</code> 只是将方法传入的值传入 <code>nextBlock</code> 再调用一次，并没有什么值得去分析的地方，而剩下的两个方法实现也差不多，会调用对应的 <code>block</code>，在这里就省略了。</p>
<h2 id="订阅的回收过程"><a href="#订阅的回收过程" class="headerlink" title="订阅的回收过程"></a>订阅的回收过程</h2><p>在创建信号时，我们向 <code>-createSignal:</code> 方法中传入了 <code>didSubscribe</code> 信号，这个 <code>block</code> 在执行结束时会返回一个 <code>RACDisposable</code> 对象，用于在订阅结束时进行必要的清理，同样也可以用于取消因为订阅创建的正在执行的任务。</p>
<p>而处理这些事情的核心类就是 <code>RACDisposable</code> 以及它的子类：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACDisposable-And-Subclasses.png" alt=""></p>
<h3 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h3><p>在继续分析讨论订阅的回收过程之前，笔者想先对 <code>RACDisposable</code> 进行简要的剖析和介绍：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACDisposable.png" alt=""></p>
<p>类 <code>RACDisposable</code> 是以 <code>_disposeBlock</code> 为核心进行组织的，几乎所有的方法以及属性其实都是对 <code>_disposeBlock</code> 进行的操作。</p>
<p><strong>关于 <code>_disposeBlock</code> 中的 self</strong></p>
<p><code>_disposeBlock</code> 是一个私有的指针变量，当 <code>void (^)(void)</code> 类型的 <code>block</code> 被传入之后都会转换成 CoreFoundation 中的类型并以 <code>void *</code> 的形式存入 <code>_disposeBlock</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (instancetype)disposableWithBlock:(void (^)(void))block &#123;</span><br><span class="line">	return [[self alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block &#123;</span><br><span class="line">	self = [super init];</span><br><span class="line"></span><br><span class="line">	_disposeBlock = (void *)CFBridgingRetain([block copy]); </span><br><span class="line">	OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>奇怪的是，<code>_disposeBlock</code> 中不止会存储代码块 <code>block</code>，还有可能存储桥接之后的 <code>self</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">	self = [super init];</span><br><span class="line"></span><br><span class="line">	_disposeBlock = (__bridge void *)self;</span><br><span class="line">	OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，刚开始看到可能会觉得比较奇怪，有两个疑问需要解决：</p>
<ol>
<li>为什么要提供一个 <code>-init</code> 方法来初始化 <code>RACDisposeable</code> 对象？</li>
<li>为什么要向 <code>_disposeBlock</code> 中传入当前对象？</li>
</ol>
<p>对于 <code>RACDisposable</code> 来说，虽然一个不包括 <code>_disposeBlock</code> 的对象没什么太多的意义，但是对于 <code>RACSerialDisposable</code> 等子类来说，却不完全是这样，因为 <code>RACSerialDisposable</code> 在 <code>-dispose</code> 时，并不需要执行 <code>disposeBlock</code>，这样就浪费了内存和 <code>CPU</code> 时间，但是同时我们需要一个合理的方法准确的判断当前对象的 <code>isDisposed</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)isDisposed &#123;</span><br><span class="line">	return _disposeBlock == NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，使用向 <code>_disposableBlock</code> 中传入 <code>NULL</code> 的方式来判断 <code>isDisposed</code>; 在 <code>-init</code> 调用时传入 <code>self</code> 而不是 <code>NULL</code> 防止状态被误判，这样就在不引入其他实例变量、增加对象的设计复杂度的同时，解决了这两个问题。</p>
<h4 id="dispose-方法的实现"><a href="#dispose-方法的实现" class="headerlink" title="-dispose: 方法的实现"></a>-dispose: 方法的实现</h4><p>这个只有不到 20 行的 方法已经是整个 <code>RACDisposable</code> 类中最复杂的方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)dispose &#123;</span><br><span class="line">	void (^disposeBlock)(void) = NULL;</span><br><span class="line"></span><br><span class="line">	while (YES) &#123;</span><br><span class="line">		void *blockPtr = _disposeBlock;</span><br><span class="line">		if (OSAtomicCompareAndSwapPtrBarrier(blockPtr, NULL, &amp;_disposeBlock)) &#123;</span><br><span class="line">			if (blockPtr != (__bridge void *)self) &#123;</span><br><span class="line">				disposeBlock = CFBridgingRelease(blockPtr);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (disposeBlock != nil) disposeBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实它的实现也没有复杂到哪里去，从 <code>_disposeBlock</code> 实例变量中调用 <code>CFBridgingRelease</code> 取出一个 <code>disposeBlock</code>，然后执行这个 <code>block</code>，整个方法就结束了。</p>
<h3 id="RACSerialDisposable"><a href="#RACSerialDisposable" class="headerlink" title="RACSerialDisposable"></a>RACSerialDisposable</h3><p><code>RACSerialDisposable</code> 是一个用于持有 <code>RACDisposable</code> 的容器，它一次只能持有一个 <code>RACDisposable</code> 的实例，并可以原子地换出容器中保存的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)swapInDisposable:(RACDisposable *)newDisposable &#123;</span><br><span class="line">	RACDisposable *existingDisposable;</span><br><span class="line">	BOOL alreadyDisposed;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">	alreadyDisposed = _disposed;</span><br><span class="line">	if (!alreadyDisposed) &#123;</span><br><span class="line">		existingDisposable = _disposable;</span><br><span class="line">		_disposable = newDisposable;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">	if (alreadyDisposed) &#123;</span><br><span class="line">		[newDisposable dispose];</span><br><span class="line">		return nil;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return existingDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程安全的 <code>RACSerialDisposable</code> 使用 <code>pthred_mutex_t</code> 互斥锁来保证在访问关键变量时不会出现线程竞争问题。</p>
<p><code>-dispose</code> 方法的处理也十分简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispose &#123;</span><br><span class="line">	RACDisposable *existingDisposable;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">	if (!_disposed) &#123;</span><br><span class="line">		existingDisposable = _disposable;</span><br><span class="line">		_disposed = YES;</span><br><span class="line">		_disposable = nil;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">	</span><br><span class="line">	[existingDisposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用锁保证线程安全，并在内部的 <code>_disposable</code> 换出之后在执行 <code>-dispose</code> 方法对订阅进行处理。</p>
<h3 id="RACCompoundDisposable"><a href="#RACCompoundDisposable" class="headerlink" title="RACCompoundDisposable"></a>RACCompoundDisposable</h3><p>与 <code>RACSerialDisposable</code> 只负责一个 <code>RACDisposable</code> 对象的释放不同；<code>RACCompoundDisposable</code> 同时负责多个 <code>RACDisposable</code> 对象的释放。</p>
<p>相比于只管理一个 <code>RACDisposable</code> 对象的 <code>RACSerialDisposable</code>，<code>RACCompoundDisposable</code> 由于管理多个对象，其实现更加复杂，而且为了性能和内存占用之间的权衡，其实现方式是通过持有两个实例变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface RACCompoundDisposable () &#123;</span><br><span class="line">    ...</span><br><span class="line">    RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line"></span><br><span class="line">    CFMutableArrayRef _disposables;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象持有的 <code>RACDisposable</code> 不超过 <code>RACCompoundDisposableInlineCount</code> 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCompoundDisposable.png" alt=""></p>
<p><code>RACCompoundDisposable</code> 在使用 <code>-initWithDisposables:</code> 初始化时，会初始化两个 <code>RACDisposable</code> 的位置用于加速销毁订阅的过程，同时为了不浪费内存空间，在默认情况下只占用两个位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithDisposables:(NSArray *)otherDisposables &#123;</span><br><span class="line">	self = [self init];</span><br><span class="line"></span><br><span class="line">	[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">		self-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line">		if (index == RACCompoundDisposableInlineCount - 1) *stop = YES;</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	if (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">		_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line">		CFRange range = CFRangeMake(RACCompoundDisposableInlineCount, (CFIndex)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line">		CFArrayAppendArray(_disposables, (__bridge CFArrayRef)otherDisposables, range);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的 <code>otherDisposables</code> 多于 <code>RACCompoundDisposableInlineCount</code>，就会创建一个新的 <code>CFMutableArrayRef</code> 引用，并将剩余的 <code>RACDisposable</code> 全部传入这个数组中。</p>
<p>在 <code>RACCompoundDisposable</code> 中另一个值得注意的方法就是 <code>-addDisposable:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line">	if (disposable == nil || disposable.disposed) return;</span><br><span class="line"></span><br><span class="line">	BOOL shouldDispose = NO;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">	&#123;</span><br><span class="line">		if (_disposed) &#123;</span><br><span class="line">			shouldDispose = YES;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">				if (_inlineDisposables[i] == nil) &#123;</span><br><span class="line">					_inlineDisposables[i] = disposable;</span><br><span class="line">					goto foundSlot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (_disposables == NULL) _disposables = RACCreateDisposablesArray();</span><br><span class="line">			CFArrayAppendValue(_disposables, (__bridge void *)disposable);</span><br><span class="line">		foundSlot:;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">	if (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在向 <code>RACCompoundDisposable</code> 中添加新的 <code>RACDisposable</code> 对象时，会先尝试在 <code>_inlineDisposables</code> 数组中寻找空闲的位置，如果没有找到，就会加入到 <code>_disposables</code> 中；但是，在添加 <code>RACDisposable</code> 的过程中也难免遇到当前 <code>RACCompoundDisposable</code> 已经 <code>dispose</code> 的情况，而这时就会直接 <code>-dispose</code> 刚刚加入的对象。</p>
<h2 id="订阅的销毁过程"><a href="#订阅的销毁过程" class="headerlink" title="订阅的销毁过程"></a>订阅的销毁过程</h2><p>在了解了 <code>ReactiveCocoa</code> 中与订阅销毁相关的类，我们就可以继续对 <code>-bind:</code> 方法的分析了，之前在分析该方法时省略了 <code>-bind:</code> 在执行过程中是如何处理订阅的清理和销毁的，所以会省略对于正常值和错误的处理过程，首先来看一下简化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        __block volatile int32_t signalCount = 1;</span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        void (^completeSignal)(RACDisposable *) = ...</span><br><span class="line">        void (^addSignal)(RACSignal *) = ...</span><br><span class="line"></span><br><span class="line">        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">        [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line">        RACDisposable *bindingDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            if (signal != nil) addSignal(signal);</span><br><span class="line">            if (signal == nil || stop) &#123;</span><br><span class="line">                [selfDisposable dispose];</span><br><span class="line">                completeSignal(selfDisposable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            completeSignal(selfDisposable);</span><br><span class="line">        &#125;];</span><br><span class="line">        selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        return compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在简化的代码中，订阅的清理是由一个 <code>RACCompoundDisposable</code> 的实例负责的，向这个实例中添加 <code>RACSerialDisposable</code> 以及 <code>RACDisposable</code> 对象，并在 <code>RACCompoundDisposable</code> 销毁时销毁。</p>
<p><code>completeSignal</code> 和 <code>addSignal</code> 两个 <code>block</code> 主要负责处理新创建信号的清理工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    if (OSAtomicDecrement32Barrier(&amp;signalCount) == 0) &#123;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        [compoundDisposable dispose];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">    OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line">    RACDisposable *disposable = [signal completed:^&#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">    &#125;];</span><br><span class="line">    selfDisposable.disposable = disposable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先通过一个例子来看一下 <code>-bind:</code> 方法调用之后，订阅是如何被清理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;Original Signal Dispose.&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        NSNumber *returnValue = @(value.integerValue);</span><br><span class="line">        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; value.integerValue; i++) [subscriber sendNext:returnValue];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                NSLog(@&quot;Binding Signal Dispose.&quot;);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在每个订阅创建以及所有的值发送之后，订阅就会被就地销毁，调用 <code>disposeBlock</code>，并从 <code>RACCompoundDisposable</code> 实例中移除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">Binding Signal Dispose.</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Binding Signal Dispose.</span><br><span class="line">Original Signal Dispose.</span><br></pre></td></tr></table></figure>
<p>原订阅的销毁时间以及绑定信号的控制是由 <code>SignalCount</code> 控制的，其表示 <code>RACCompoundDisposable</code> 中的 <code>RACSerialDisposable</code> 实例的个数，在每次有新的订阅被创建时都会向 <code>RACCompoundDisposable</code> 加入一个新的 <code>RACSerialDisposable</code>，并在订阅发送结束时从数组中移除，整个过程用图示来表示比较清晰：</p>
<p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Bind-Disposable.png" alt=""></p>
<p>紫色的 <code>RACSerialDisposable</code> 为原订阅创建的对象，灰色的为新信号订阅的对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RAC</code> 中绝大多数的方法都相当简洁，行数并不多，代码的组织方式很多，值得大家去阅读与学习。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RAC/" rel="tag"># RAC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/22/Objective-C/2019/iOS 版本兼容与判断/" rel="next" title="iOS 版本兼容与判断">
                <i class="fa fa-chevron-left"></i> iOS 版本兼容与判断
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/25/Objective-C/ReactiveObjc/RACMulticastConnection的用法/" rel="prev" title="RACMulticastConnection的用法">
                RACMulticastConnection的用法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/avatar-photo.png"
                alt="Eric Huang" />
            
              <p class="site-author-name" itemprop="name">Eric Huang</p>
              <p class="site-description motion-element" itemprop="description">~ 生活不止苟且，还有诗和远方，迎着朝阳前进，看风与雪。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/huangzhifei" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/chongzizizizizizi/home?leftnav=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReactiveCocoa-与信号"><span class="nav-number">1.</span> <span class="nav-text">ReactiveCocoa 与信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RACSignal-简介"><span class="nav-number">2.</span> <span class="nav-text">RACSignal 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RACStream"><span class="nav-number">3.</span> <span class="nav-text">RACStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RACSignal-细说"><span class="nav-number">4.</span> <span class="nav-text">RACSignal 细说</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号的创建"><span class="nav-number">5.</span> <span class="nav-text">信号的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RACSignal-类簇"><span class="nav-number">6.</span> <span class="nav-text">RACSignal 类簇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号的订阅与信息的发送"><span class="nav-number">7.</span> <span class="nav-text">信号的订阅与信息的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号的订阅"><span class="nav-number">7.1.</span> <span class="nav-text">信号的订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息的发送"><span class="nav-number">7.2.</span> <span class="nav-text">信息的发送</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#订阅的回收过程"><span class="nav-number">8.</span> <span class="nav-text">订阅的回收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RACDisposable"><span class="nav-number">8.1.</span> <span class="nav-text">RACDisposable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dispose-方法的实现"><span class="nav-number">8.1.1.</span> <span class="nav-text">-dispose: 方法的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RACSerialDisposable"><span class="nav-number">8.2.</span> <span class="nav-text">RACSerialDisposable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RACCompoundDisposable"><span class="nav-number">8.3.</span> <span class="nav-text">RACCompoundDisposable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#订阅的销毁过程"><span class="nav-number">9.</span> <span class="nav-text">订阅的销毁过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Huang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://huangzhifei.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://huangzhifei.github.io/2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/';
          this.page.identifier = '2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/';
          this.page.title = 'RACSignal的用法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://huangzhifei.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
