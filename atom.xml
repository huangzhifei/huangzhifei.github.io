<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EricHuang&#39;s blog</title>
  
  <subtitle>每一个不码代码的日子，都是对生命的辜负!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangzhifei.github.io/"/>
  <updated>2020-01-05T02:55:03.366Z</updated>
  <id>https://huangzhifei.github.io/</id>
  
  <author>
    <name>Eric Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSURLProtocol 小玩一把</title>
    <link href="https://huangzhifei.github.io/2019/09/06/Objective-C/2019/NSURLProtocol%20%E5%B0%8F%E7%8E%A9%E4%B8%80%E6%8A%8A/"/>
    <id>https://huangzhifei.github.io/2019/09/06/Objective-C/2019/NSURLProtocol 小玩一把/</id>
    <published>2019-09-06T07:47:46.000Z</published>
    <updated>2020-01-05T02:55:03.366Z</updated>
    
    <content type="html"><![CDATA[<p>NSURLProtocol 用来拦截所的 URL Load system 的请求，然后做一些相关处理，具体的文档可以参照 <a href="https://nshipster.cn/nsurlprotocol/" target="_blank" rel="noopener">NSURLProtocol</a>，下面是项目中使用的相关代码，里面有关键点的注释。</p><p>地址：<a href="https://github.com/huangzhifei/HZFHTTPProtolcol" target="_blank" rel="noopener">HZFHTTPProtolcol</a></p><p>后面有时间在来补充文章吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NSURLProtocol 用来拦截所的 URL Load system 的请求，然后做一些相关处理，具体的文档可以参照 &lt;a href=&quot;https://nshipster.cn/nsurlprotocol/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS13适配</title>
    <link href="https://huangzhifei.github.io/2019/08/05/Objective-C/2019/iOS13%E9%80%82%E9%85%8D/"/>
    <id>https://huangzhifei.github.io/2019/08/05/Objective-C/2019/iOS13适配/</id>
    <published>2019-08-05T08:28:20.000Z</published>
    <updated>2020-01-05T02:55:03.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-13-系统禁止通过-KVC-访问"><a href="#iOS-13-系统禁止通过-KVC-访问" class="headerlink" title="iOS 13 系统禁止通过 KVC 访问"></a>iOS 13 系统禁止通过 KVC 访问</h2><h3 id="1、UITextField"><a href="#1、UITextField" class="headerlink" title="1、UITextField"></a>1、UITextField</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UITextField *textField = [UITextField new];</span><br><span class="line">[textField valueForKey:@&quot;_placeholderLabel&quot;];</span><br></pre></td></tr></table></figure><p>系统的 UITextField 重写了 valueForKey: 拦截了外部的取值，实现如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation UITextField</span><br><span class="line"></span><br><span class="line">- (id)valueForKey:(NSString *)key &#123;</span><br><span class="line">    if ([key isEqualToString:@&quot;_placeholderLabel&quot;]) &#123;</span><br><span class="line">        [NSException raise:NSGenericException format:@&quot;Access to UITextField&apos;s _placeholderLabel ivar is prohibited. This is an application bug&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    [super valueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>简单解决：<br>去掉下划线即可 <code>[textField valueForKey:@&quot;placeholderLabel&quot;];</code></p><h3 id="2、UISearchBar"><a href="#2、UISearchBar" class="headerlink" title="2、UISearchBar"></a>2、UISearchBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UISearchBar *bar = [UISearchBar new];</span><br><span class="line">[bar setValue:@&quot;test&quot; forKey:@&quot;_cancelButtonText&quot;]</span><br><span class="line">UIView *searchField = [bar valueForKey:@&quot;_searchField&quot;];</span><br></pre></td></tr></table></figure><p>根据 KVC 的实现，会先去找名为 set_cancelButtonText 的方法，所以系统内部重写了这个方法，什么事都不干，专门用来拦截 KVC，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)set_cancelButtonText:(NSString *)text &#123;</span><br><span class="line">    [NSException raise:NSGenericException format:@&quot;Access to UISearchBar&apos;s set_cancelButtonText: ivar is prohibited. This is an application bug&quot;];</span><br><span class="line">    [self _setCancelButtonText];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截 _searchField：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)_searchField &#123;</span><br><span class="line">    [NSException raise:NSGenericException format:@&quot;Access to UISearchBar&apos;s _searchField ivar is prohibited. This is an application bug&quot;];</span><br><span class="line">    [self searchField];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解决：<br>直接调用 <code>_setCancelButtonText, searchField</code></p><p>根据上面提到的原理，这里提供一种全局绕过这个禁止的方法供参考。<br>请注意：这只是一种临时的参考方案，我们 不推荐 开发者这么做， 因为访问私有属性会带来了不确定和不稳定性，少了苹果的警告会让你无节制去访问使用各种属性，随着系统的升级这私有属性会面临改动和失效的风险。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSException (DisableUIKVCAccessProhibited)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getClassMethod(self, @selector(raise:format:));</span><br><span class="line">        Method swizzlingMethod = class_getClassMethod(self, @selector(sw_raise:format:));</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)sw_raise:(NSExceptionName)raise format:(NSString *)format, ... &#123;</span><br><span class="line">    if (raise == NSGenericException &amp;&amp; [format isEqualToString:@&quot;Access to %@&apos;s %@ ivar is prohibited. This is an application bug&quot;]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    NSString *reason =  [[NSString alloc] initWithFormat:format arguments:args];</span><br><span class="line">    [self sw_raise:raise format:reason];</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS-13-系统禁止通过-KVC-访问&quot;&gt;&lt;a href=&quot;#iOS-13-系统禁止通过-KVC-访问&quot; class=&quot;headerlink&quot; title=&quot;iOS 13 系统禁止通过 KVC 访问&quot;&gt;&lt;/a&gt;iOS 13 系统禁止通过 KVC 访问&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>APP 缓存增加模型</title>
    <link href="https://huangzhifei.github.io/2019/05/17/Objective-C/2019/APP%20%E7%BC%93%E5%AD%98%E5%A2%9E%E5%8A%A0%E6%A8%A1%E5%9E%8B/"/>
    <id>https://huangzhifei.github.io/2019/05/17/Objective-C/2019/APP 缓存增加模型/</id>
    <published>2019-05-17T06:41:06.000Z</published>
    <updated>2020-01-05T02:55:03.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="APP-持久化缓存增量更新方案"><a href="#APP-持久化缓存增量更新方案" class="headerlink" title="APP 持久化缓存增量更新方案"></a>APP 持久化缓存增量更新方案</h1><p>客户端和服务端的数据同步过程中，客户端有缓存，不需要每次都是全量刷新，所以可以采用增量的方式更新。</p><p>每次在客户端进行刷新的时候，服务端会将最新的增删改操作推送到客户端，客户端对其缓存进行操作，以保持数据的同步。</p><h2 id="一、最原始的全理更新"><a href="#一、最原始的全理更新" class="headerlink" title="一、最原始的全理更新"></a>一、最原始的全理更新</h2><p>略……</p><h2 id="二、根据修改时间来拉取增、删、改信息-Timestamp-Transfer-透传通知更新（App-启动后的长连接，push-不靠谱）"><a href="#二、根据修改时间来拉取增、删、改信息-Timestamp-Transfer-透传通知更新（App-启动后的长连接，push-不靠谱）" class="headerlink" title="二、根据修改时间来拉取增、删、改信息 Timestamp Transfer + 透传通知更新（App 启动后的长连接，push 不靠谱）"></a>二、根据修改时间来拉取增、删、改信息 Timestamp Transfer + 透传通知更新（App 启动后的长连接，push 不靠谱）</h2><p>客户端存储上次拉取的数据的 Timestamp，在请求更新数据时，携带该 Timestamp 作为本地数据版本信息。数据库内每行数据设置一个 LAST_UPDATE_TIME 字段，服务器将比该时间更新的数据返回给客户端。</p><p><strong>优点：</strong></p><p><strong>1、相对于全量来说减少了冗余数据的传输</strong></p><p><strong>缺点：</strong></p><p><strong>1、传输时 Timestamp 作为版本信息需要精确控制，请求错误的版本号可能带来本地数据的不准确。</strong></p><p><strong>2、已经删除的数据其实已经不存在了，取不到 LAST_UPDATE_TIME</strong></p><p><strong>3、要注意删除的记录不能物理删除，防止其他端同步不到这条数据</strong></p><p><strong>场景：</strong></p><p>通讯录：<br>1、app 上没有任何缓存记录，那么可以一次全量同步，或者分批多次同步<br>2、app 上有缓存，有一段时间没有使用app，不能确定缓存是否为最新，需要增量同步<br>3、app 使用频率相对高，正常增量同步</p><p>在上述三个场景中，最麻烦的就是场景2，因为可能出现 server 在 app 不使用的时间内对通讯录中的信息进行了 CRUD（增、读、更、删）操作。</p><p><strong>下面我们使用 updateTime 和 isDeleted 来分析</strong></p><p>为了应付场景2，通常采用增量更新的手段，即每条数据都加上 update_time 字段，来确认哪些数据是在 app 不使用时间或其他端更改生成的，每次 app 收到类似于透传通知，或人为主动拉取的时候，发送本地最新的更新时间戳（版本)，server 返回比这个要新的所有内容（增量），以 CRUD 分步说明：</p><p>1、对于C（新增create）：如果server向数据库中通讯录添加一条数据，且该数据的 update_time 为server 当前时间，这条记录 app 在同步的时候，就会获得。<br>2、对于R（读取read）：无任何影响<br>3、对于U（更新update）：server或其他端修改通讯录条目的时候，也会修改update_time为入库时间，这样子，app在同步的时候，server就知道返回哪些数据给 app 了。<br>4、对于D（删除delete）：服务端不能物理删除记录，只能增加标记位is_delete，不然app本地的缓存永远不知道这条数据被删除了。</p><p>些方案主要依赖 update_time 的精确度，透传通知是用来增加时效性的。</p><h2 id="三、增删改日志-SYNC"><a href="#三、增删改日志-SYNC" class="headerlink" title="三、增删改日志 - SYNC"></a>三、增删改日志 - SYNC</h2><p>服务端记录数据的每次操作都记录进一个增量数据库，数据库内记录了每条操作的对象 ID 和操作的内容。此处思想类似于 Patch 补丁操作，客户端发送一个 Timestamp 信息，服务器将这个时间以后的所有增删改操作返回给客户端，客户端再进行打补丁操作，使得最终结果与服务端同步。</p><p><strong>优点：</strong></p><p><strong>1、保持了所有数据的精确可同步</strong></p><p><strong>缺点：</strong></p><p><strong>1、客户端很久不更新以后单次的更新补丁很大</strong></p><p><strong>2、如果数据改动很多，那记录操作的表将会变得很大</strong></p><p><strong>参考文章：</strong><a href="">https://my.oschina.net/shinedev/blog/506739</a> <strong>注意看文章最后的评论，精华都在评论</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;APP-持久化缓存增量更新方案&quot;&gt;&lt;a href=&quot;#APP-持久化缓存增量更新方案&quot; class=&quot;headerlink&quot; title=&quot;APP 持久化缓存增量更新方案&quot;&gt;&lt;/a&gt;APP 持久化缓存增量更新方案&lt;/h1&gt;&lt;p&gt;客户端和服务端的数据同步过程中，客户
      
    
    </summary>
    
      <category term="持久化缓存" scheme="https://huangzhifei.github.io/categories/%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Category中方法名冲突了怎么办？</title>
    <link href="https://huangzhifei.github.io/2019/04/01/Objective-C/2019/Category%E4%B8%AD%E6%96%B9%E6%B3%95%E5%90%8D%E5%86%B2%E7%AA%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <id>https://huangzhifei.github.io/2019/04/01/Objective-C/2019/Category中方法名冲突了怎么办？/</id>
    <published>2019-04-01T14:42:56.000Z</published>
    <updated>2020-01-05T02:55:03.366Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在 Category 里写了与主类同名的方法后，按照 oc 的消息机制调用，会调用 Category 的方法，而主类的同名方法看起来像是被覆盖了。是否真的是被覆盖了？</p><h2 id="Category-方法存在位置"><a href="#Category-方法存在位置" class="headerlink" title="Category 方法存在位置"></a>Category 方法存在位置</h2><p>实际上，Category 并没有覆盖主类的同名方法，只是 Category 的方法排在主类方法的前面，而主类的方法被移到了方法列表的后面，对于 oc 的消息发送机制，他是根据方法名在 method_list 中查找方法，找到第一个名字匹配的方法之后就不继续往下找了，所以每次调用的都是 method_list 中最前面的同名方法，实际上其他同名的方法还在 method_list 中。</p><p>所以我们可以根据 selector 查找到这类的所有同名 method，然后倒序调用（主类的同名方法在最后面）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取类的方法列表</span><br><span class="line">    uint count;</span><br><span class="line">    Method *list = class_copyMethodList([target class], &amp;count);</span><br><span class="line"></span><br><span class="line">    // 找到主类的方法，并执行，主类的肯定在分类的后面，所以我们倒序，找到就退出，防止循环嵌套调用后列循环。</span><br><span class="line">    for ( int i = count - 1 ; i &gt;= 0; i--) &#123;</span><br><span class="line">        Method method = list[i];</span><br><span class="line">        SEL name = method_getName(method);</span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        if (name == selector) &#123;</span><br><span class="line">            ((void (*)(id, SEL))imp)(target, name);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(list);</span><br></pre></td></tr></table></figure><h2 id="多个-Category-的情况？"><a href="#多个-Category-的情况？" class="headerlink" title="多个 Category 的情况？"></a>多个 Category 的情况？</h2><p>我们来看看同时定义了多个分类，且都有方法重名的问题，那调用情况是什么样子的？哪个分类的方法会生效？（主类肯定不会生效）</p><p>其实这里根编译时的顺序有关（原先我一直以为是随机的，真是孤陋寡闻），我们主要看这几个分类在 Build Phases -&gt; Compile Sources 下面的顺序，分类的顺序靠后，那么他就会后编译，谁后编译，谁就会被调用。</p><p>为什么？</p><p>因为最后编译的那个 Category，其方法被放在了方法列表的前面，所以会最先找到他。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们在分类中触发调用主类的方法时，要注意不能造成死循环，也要注意一下父类的方法调用等。</p><p>创建个 NSObject 的分类，留个方法入参 class + selector<br><code>NSObject+InvokeOriginalMethod.h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (InvokeOriginalMethod)</span><br><span class="line"></span><br><span class="line">+ (void *)invokeOriginalMethod:(id)target selector:(SEL)selector;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><code>NSObject+InvokeOriginalMethod.m</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">+ (void *)invokeOriginalMethod:(id)target selector:(SEL)selector &#123;</span><br><span class="line">    void *result = NULL;</span><br><span class="line"></span><br><span class="line">    // Get the class method list</span><br><span class="line">    uint count;</span><br><span class="line">    Method *methodList = class_copyMethodList([target class], &amp;count);</span><br><span class="line"></span><br><span class="line">    // check the number of same name</span><br><span class="line">    int number = 0;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL name = method_getName(method);</span><br><span class="line">        if (name == selector) &#123;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if only one (just itself), then call super, forbid recursively call.</span><br><span class="line">    if (number == 1) &#123;</span><br><span class="line">        IMP implementation = [self getSuperClassImplementation:target selector:selector];</span><br><span class="line">        // id (*IMP)(id, SEL, ...)</span><br><span class="line">        result = ((void *(*) (id, SEL)) implementation)(target, selector);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Call original method . Note here take the last same name method as the original method</span><br><span class="line">        for (int i = count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            Method method = methodList[i];</span><br><span class="line">            SEL name = method_getName(method);</span><br><span class="line">            IMP implementation = method_getImplementation(method);</span><br><span class="line">            if (selector == name) &#123;</span><br><span class="line">                // id (*IMP)(id, SEL, ...)</span><br><span class="line">                result = ((void *(*) (id, SEL)) implementation)(target, selector);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(methodList);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (IMP)getSuperClassImplementation:(id)target selector:(SEL)selector &#123;</span><br><span class="line">    IMP implementation = NULL;</span><br><span class="line">    Class superClazz = [target superclass];</span><br><span class="line">    while (superClazz) &#123;</span><br><span class="line">        uint count;</span><br><span class="line">        Method *methodList = class_copyMethodList(superClazz, &amp;count);</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            Method method = methodList[i];</span><br><span class="line">            SEL name = method_getName(method);</span><br><span class="line">            if (name == selector) &#123;</span><br><span class="line">                implementation = method_getImplementation(method);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (implementation) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            superClazz = [superClazz superclass];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return implementation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上面的一些注释的地方。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们可以给 <code>ViewController</code> 的 <code>- viewDidLoad</code> 方法增加一个分类，方法名一样。</p><p>先看主类：</p><p><code>ViewController.m</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;ViewController %@&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分类：<br><code>ViewController+AViewControllerCategory.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController (AViewControllerCategory)</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>ViewController+AViewControllerCategory.m</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController (AViewControllerCategory)</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;AViewControllerCategory %@&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">    [NSObject invokeOriginalMethod:self selector:_cmd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>在分类中使用我们 hook 方法去触发主类的同名方法调用。</p><p>打印输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AViewControllerCategory viewDidLoad</span><br><span class="line">ViewController viewDidLoad</span><br></pre></td></tr></table></figure><p>参考链接：<a href="">https://blog.csdn.net/WOTors/article/details/52576433</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，在 Category 里写了与主类同名的方法后，按照 oc 的消息机制调用，会调用 Category 的方法，而主类的同名方法看起来像是被覆盖了。是否真的是被覆盖了？&lt;/p&gt;
&lt;h2 id=&quot;Category-方法存在位置&quot;&gt;&lt;a href=&quot;#Category-
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>RACMulticastConnection的用法</title>
    <link href="https://huangzhifei.github.io/2019/03/25/Objective-C/ReactiveObjc/RACMulticastConnection%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://huangzhifei.github.io/2019/03/25/Objective-C/ReactiveObjc/RACMulticastConnection的用法/</id>
    <published>2019-03-25T13:11:10.000Z</published>
    <updated>2020-01-05T02:55:03.370Z</updated>
    
    <content type="html"><![CDATA[<p><code>RACMulticastConnection</code> 是用于多播的，在 <code>RAC</code> 中的信号在默认情况下都是冷的，每次有新的订阅者订阅信号时都会执行信号创建时传入的 <code>block</code>，这意味着对于任意一个订阅者，所需要的数据都会重新计算，这在大多数情况下都是开发者想看到的情况，但是这个信号中的 <code>block</code> 有副作用或者较为昂贵时就会很多问题。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACMulticastConnection.png" alt=""></p><p>我们希望有一种模型能够将冷信号转变为热信号，并在合适的时间触发，向所有的订阅者发送消息，而今天的主角就是用于解决上述问题的。</p><h2 id="RACMulticastConnection-简介"><a href="#RACMulticastConnection-简介" class="headerlink" title="RACMulticastConnection 简介"></a>RACMulticastConnection 简介</h2><p><code>RACMulticastConnection</code> 封装了将一个信号的订阅分享给多个订阅者的思想，它的每一个对象都持有两个 <code>RACSignal</code>：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACMulticastConnection-Interface.png" alt=""></p><p>一个是私有的源信号 <code>sourceSignal</code>，另一个是用于广播的信号 <code>signal</code>，其实是一个 <code>RACSubject</code> 对象，不过对外只提供 <code>RACSignal</code> 接口，用于使用者通过 <code>-subscribeNext:</code> 等方法进行订阅。</p><h2 id="RACMulticastConnection-的初始化"><a href="#RACMulticastConnection-的初始化" class="headerlink" title="RACMulticastConnection 的初始化"></a>RACMulticastConnection 的初始化</h2><p><code>RACMulticastConnection</code> 有一个非常简单的初始化方法 <code>-initWithSourceSignal:subject:</code>，不过这个初始化方法是私有的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject &#123;</span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_sourceSignal = source;</span><br><span class="line">_serialDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">_signal = subject;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>RACMulticastConnection</code> 的头文件的注释中，对它的初始化有这样的说明：</p><p><code>Note that you shouldn&#39;t create RACMulticastConnection manually. Instead use -[RACSignal publish] or -[RACSignal multicast:].</code></p><p>我们不应该直接使用 <code>-initWithSourceSignal:subject:</code> 来初始化一个对象，我们应该通过 <code>RACSignal</code> 的实例方法初始化 <code>RACMulticastConnection</code> 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACMulticastConnection *)publish &#123;</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACMulticastConnection *connection = [self multicast:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;</span><br><span class="line">RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法 <code>-publish</code> 和 <code>-multicast:</code> 都是对初始化方法的封装，并且都会返回一个 <code>RACMulticastConnection</code> 对象，传入的 <code>sourceSignal</code> 就是当前信号，<code>subject</code> 就是用于对外广播的 <code>RACSubject</code> 对象。</p><h2 id="RACSignal-和-RACMulticastConnection"><a href="#RACSignal-和-RACMulticastConnection" class="headerlink" title="RACSignal 和 RACMulticastConnection"></a>RACSignal 和 RACMulticastConnection</h2><p>网络请求在客户端其实是一个非常昂贵的操作，也算是多级缓存中最慢的一级，在使用 <code>ReactiveCocoa</code> 处理业务需求中经常会遇到下面的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;Send Request&quot;);</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://localhost:3000&quot;];</span><br><span class="line">    AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:url];</span><br><span class="line">    NSString *URLString = [NSString stringWithFormat:@&quot;/api/products/1&quot;];</span><br><span class="line">    NSURLSessionDataTask *task = [manager GET:URLString parameters:nil progress:nil</span><br><span class="line">                                      success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;</span><br><span class="line">                                          [subscriber sendNext:responseObject];</span><br><span class="line">                                          [subscriber sendCompleted];</span><br><span class="line">                                      &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">                                          [subscriber sendError:error];</span><br><span class="line">                                      &#125;];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        [task cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[requestSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;product: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[requestSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSNumber *productId = [x objectForKey:@&quot;id&quot;];</span><br><span class="line">    NSLog(@&quot;productId: %@&quot;, productId);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>通过订阅发出网络请求的信号经常会被多次订阅，以满足不同 <code>UI</code> 组件更新的需求，但是以上代码却有非常严重的问题。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-And-Subscribe.png" alt=""></p><p>每一次在 <code>RACSignal</code> 上执行 <code>-subscribeNext:</code> 以及类似方法时，都会发起一次新的网络请求，我们希望避免这种情况的发生。</p><p>为了解决上述问题，我们使用了 <code>-publish</code> 方法获得一个多播对象 <code>RACMulticastConnection</code>，更改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;Send Request&quot;);</span><br><span class="line">    ...</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;product: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSNumber *productId = [x objectForKey:@&quot;id&quot;];</span><br><span class="line">    NSLog(@&quot;productId: %@&quot;, productId);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>-publish</code> 方法生成实例，订阅者不再订阅源信号，而是订阅 <code>RACMulticastConnection</code> 中的 <code>RACSubject</code> 热信号，最后通过 <code>-connect</code> 方法触发源信号中的任务。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-RACMulticastConnection-Connect.png" alt=""></p><h3 id="publish-和-multicast-方法"><a href="#publish-和-multicast-方法" class="headerlink" title="publish 和 multicast 方法"></a>publish 和 multicast 方法</h3><p>我们再来看一下 <code>-publish</code> 和 <code>-multicast:</code> 这两个方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACMulticastConnection *)publish &#123;</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACMulticastConnection *connection = [self multicast:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;</span><br><span class="line">RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];</span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>-publish</code> 方法调用时相当于向 <code>-multicast:</code> 传入了 <code>RACSubject</code>。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/publish-and-multicast.png" alt=""></p><p><code>-publish</code> 只是对 <code>-multicast:</code> 方法的简单封装，它们都是通过 <code>RACMulticastConnection</code> 私有的初始化方法 <code>-initWithSourceSignal:subject:</code> 创建一个新的实例。</p><p>在使用 <code>-multicast:</code> 方法时，传入的信号其实就是用于广播的信号；这个信号必须是一个 <code>RACSubject</code> 本身或者它的子类：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSubject-Subclasses.png" alt=""></p><p>传入 <code>-multicast:</code> 方法的一般都是 <code>RACSubject</code> 或者 <code>RACReplaySubject</code> 对象。</p><h3 id="订阅源信号的时间点"><a href="#订阅源信号的时间点" class="headerlink" title="订阅源信号的时间点"></a>订阅源信号的时间点</h3><p>订阅 <code>connection.signal</code> 中的数据流时，其实只是向多播对象中的热信号 <code>RACSubject</code> 持有的数组中加入订阅者，而这时刚刚创建的 <code>RACSubject</code> 中并没有任何的消息。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/SubscribeNext-To-RACSubject-Before-Connect.png" alt=""></p><p>只有在调用 <code>-connect</code> 方法之后，<code>RACSubject</code> 才会订阅源信号 <code>sourceSignal</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)connect &#123;</span><br><span class="line">self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];</span><br><span class="line">return self.serialDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时源信号的 <code>didSubscribe</code> 代码块才会执行，向 <code>RACSubject</code> 推送消息，消息向下继续传递到 <code>RACSubject</code> 所有的订阅者中。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Values-From-RACSignal-To-Subscribers.png" alt=""></p><p><code>-connect</code> 方法通过 <code>-subscribe:</code> 实际上建立了 <code>RACSignal</code> 和 <code>RACSubject</code> 之间的连接，这种方式保证了 <code>RACSignal</code> 中的 <code>didSubscribe</code> 代码块只执行了一次。</p><p>所有的订阅者不再订阅原信号，而是订阅 <code>RACMulticastConnection</code> 持有的热信号 <code>RACSubject</code>，实现对冷信号的一对多传播。</p><p>在 <code>RACMulticastConnection</code> 中还有另一个用于连接 <code>RACSignal</code> 和 <code>RACSubject</code> 信号的 <code>-autoconnect</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)autoconnect &#123;</span><br><span class="line">__block volatile int32_t subscriberCount = 0;</span><br><span class="line">return [RACSignal</span><br><span class="line">createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">OSAtomicIncrement32Barrier(&amp;subscriberCount);</span><br><span class="line">RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];</span><br><span class="line">RACDisposable *connectionDisposable = [self connect];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">if (OSAtomicDecrement32Barrier(&amp;subscriberCount) == 0) &#123;</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它保证了在 <code>-autoconnect</code> 方法返回的对象被第一次订阅时，就会建立源信号与热信号之间的连接。</p><h3 id="使用-RACReplaySubject-订阅源信号"><a href="#使用-RACReplaySubject-订阅源信号" class="headerlink" title="使用 RACReplaySubject 订阅源信号"></a>使用 RACReplaySubject 订阅源信号</h3><p>虽然使用 <code>-publish</code> 方法已经能够解决大部分问题了，但是在 <code>-connect</code> 方法调用之后才订阅的订阅者并不能收到消息。</p><p>如何才能保存 <code>didSubscribe</code> 执行过程中发送的消息，并在 <code>-connect</code> 调用之后也可以收到消息？这时，我们就要使用 <code>-multicast:</code> 方法和 <code>RACReplaySubject</code> 来完成这个需求了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *sourceSignal = [RACSignal createSignal:...];</span><br><span class="line">RACMulticastConnection *connection = [sourceSignal multicast:[RACReplaySubject subject]];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;product: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection connect];</span><br><span class="line">[connection.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSNumber *productId = [x objectForKey:@&quot;id&quot;];</span><br><span class="line">    NSLog(@&quot;productId: %@&quot;, productId);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>除了使用上述的代码，也有一个更简单的方式创建包含 <code>RACReplaySubject</code> 对象的 <code>RACMulticastConnection</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [[RACSignal createSignal:...] replay];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;product: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSNumber *productId = [x objectForKey:@&quot;id&quot;];</span><br><span class="line">    NSLog(@&quot;productId: %@&quot;, productId);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>-replay</code> 方法和 <code>-publish</code> 差不多，只是内部封装的热信号不同，并在方法调用时就连接原信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)replay &#123;</span><br><span class="line">RACReplaySubject *subject = [RACReplaySubject subject];</span><br><span class="line">RACMulticastConnection *connection = [self multicast:subject];</span><br><span class="line">[connection connect];</span><br><span class="line">return connection.signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>-replay</code> 方法，<code>RACSignal</code> 中还定义了与 <code>RACMulticastConnection</code> 中相关的其它 <code>-replay</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)replay;</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)replayLast;</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)replayLazily;</span><br></pre></td></tr></table></figure><p>三个方法都会在 <code>RACMulticastConnection</code> 初始化时传入一个 <code>RACReplaySubject</code> 对象，不过却有一点细微的差别：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Difference-Between-Replay-Methods.png" alt=""></p><p>相比于 <code>-replay</code> 方法，<code>-replayLast</code> 方法生成的 <code>RACMulticastConnection</code> 中热信号的容量为 <code>1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)replayLast &#123;</span><br><span class="line">RACReplaySubject *subject = [RACReplaySubject replaySubjectWithCapacity:1];</span><br><span class="line">RACMulticastConnection *connection = [self multicast:subject];</span><br><span class="line">[connection connect];</span><br><span class="line">return connection.signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>replayLazily</code> 会在返回的信号被第一次订阅时，才会执行 <code>-connect</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)replayLazily &#123;</span><br><span class="line">RACMulticastConnection *connection = [self multicast:[RACReplaySubject subject]];</span><br><span class="line">return [RACSignal</span><br><span class="line">defer:^&#123;</span><br><span class="line">[connection connect];</span><br><span class="line">return connection.signal;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RACMulticastConnection</code> 在处理冷热信号相互转换时非常好用，在 <code>RACSignal</code> 中也提供了很多将原有的冷信号通过 <code>RACMulticastConnection</code> 转换成热信号的方法。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACMulticastConnection1.png" alt=""></p><p>在遇到冷信号中的行为有副作用后者非常昂贵时，我们就可以使用这些方法将单播变成多播，提高执行效率，减少副作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;RACMulticastConnection&lt;/code&gt; 是用于多播的，在 &lt;code&gt;RAC&lt;/code&gt; 中的信号在默认情况下都是冷的，每次有新的订阅者订阅信号时都会执行信号创建时传入的 &lt;code&gt;block&lt;/code&gt;，这意味着对于任意一个订阅者，所
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>RACSignal的用法</title>
    <link href="https://huangzhifei.github.io/2019/03/22/Objective-C/ReactiveObjc/RACSignal%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://huangzhifei.github.io/2019/03/22/Objective-C/ReactiveObjc/RACSignal的用法/</id>
    <published>2019-03-22T14:48:42.000Z</published>
    <updated>2020-01-05T02:55:03.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactiveCocoa-与信号"><a href="#ReactiveCocoa-与信号" class="headerlink" title="ReactiveCocoa 与信号"></a>ReactiveCocoa 与信号</h2><p><code>RAC</code> 将原有的各种设计模式，包括代理、<code>Target-Action</code>、通知中心以观察者模式各种各种『输入』，都抽象成信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。</p><p>在 <code>RAC</code> 中最重要的信号，也就是 <code>RACSignal</code> 对象是这一篇文章的核心，文章主要会介绍下面的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;dispose&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在上述代码执行时，会在控制台中打印出以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">dispose</span><br></pre></td></tr></table></figure><p>代码片段基本都是围绕 <code>RACSignal</code> 类进行的，接下来主要分成以下几点来展开：</p><ul><li>简单了解 <code>RACSignal</code></li><li>信号的创建</li><li>信号的订阅与发送</li><li>订阅的回收过程</li></ul><h2 id="RACSignal-简介"><a href="#RACSignal-简介" class="headerlink" title="RACSignal 简介"></a>RACSignal 简介</h2><p><code>RACSignal</code> 其实是抽象类 <code>RACStream</code> 的子类，在整个 <code>RAC</code> 工程中有另一个类 <code>RACSequence</code> 也继承自抽象类 <code>RACStream</code>：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Hierachy.png" alt=""></p><p><code>RACSignal</code> 是 <code>RAC</code> 的核心，他可以简单理解为一连串的状态:</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACSignal.png" alt=""></p><p>在状态改变时，对应的订阅者 RACSubscriber    就会收到通知执行相应的指令，在 <code>RAC</code> 的世界中所有的消息都是通过信号的方式来传递的，原有的设计模式都会简化为一种模型。</p><h2 id="RACStream"><a href="#RACStream" class="headerlink" title="RACStream"></a>RACStream</h2><p><code>RACStream</code> 作为抽象类本身不提供方法的实现，其实现内部原生提供的而方法都是抽象方法，会在调用时直接抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (__kindof RACStream *)empty &#123;</span><br><span class="line">NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];</span><br><span class="line">@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;</span><br><span class="line">+ (__kindof RACStream *)return:(id)value;</span><br><span class="line">- (__kindof RACStream *)concat:(RACStream *)stream;</span><br><span class="line">- (__kindof RACStream *)zipWith:(RACStream *)stream;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACStream-AbstractMethod.png" alt=""></p><p>上面的这些抽象方法都需要子类覆写，不过 <code>RACStream</code> 在 <code>Operations</code> 分类中使用上面的抽象方法提供了丰富的内容，比如说 <code>-flattenMap:</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block &#123;</span><br><span class="line">Class class = self.class;</span><br><span class="line"></span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">return ^(id value, BOOL *stop) &#123;</span><br><span class="line">id stream = block(value) ?: [class empty];</span><br><span class="line">NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);</span><br><span class="line"></span><br><span class="line">return stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法比如 <code>-skip:</code>、<code>-take:</code>、<code>-ignore：</code> 等等实例方法都构建在这些抽象方法之上，只要子类覆写了所有抽象方法就能自动获得所有的 <code>Operation</code> 分类中的方法。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACStream-Operation.png" alt=""></p><h2 id="RACSignal-细说"><a href="#RACSignal-细说" class="headerlink" title="RACSignal 细说"></a>RACSignal 细说</h2><p><code>RAC</code> 框架借鉴了很多平台的概念，就比如 <code>RACStream</code> 的抽象方法 <code>+return:</code> 和 <code>-bind:</code><br>首先我们来看一下 <code>+return:</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">return [RACReturnSignal return:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改方法接受一个 <code>NSObject</code> 对象，并返回一个 <code>RACSignal</code> 的实例，它会将一个 <code>Foundation</code> 世界的对象 <code>NSObject</code> 转换成 <code>RAC</code> 中的 <code>RACSignal</code></p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Return.png" alt=""></p><p>而 <code>RACReturnSignal</code> 也仅仅是把 <code>NSObject</code> 对象包装一下，并没有做什么复杂的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br><span class="line">return signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>-bind:</code> 方法的实现相比之下就十分复杂了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        return [self subscribeNext:^(id x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            if (signal != nil) &#123;</span><br><span class="line">                [signal subscribeNext:^(id x) &#123;</span><br><span class="line">                    [subscriber sendNext:x];</span><br><span class="line">                &#125; error:^(NSError *error) &#123;</span><br><span class="line">                    [subscriber sendError:error];</span><br><span class="line">                &#125; completed:^&#123;</span><br><span class="line">                    [subscriber sendCompleted];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            if (signal == nil || stop) &#123;</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; error:^(NSError *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>上面对 bind 方法进行一些省略，省掉了对 RACDisposable 的处理。</code></p><p><code>-bind:</code> 方法会在原信号每次发出消息时，都执行 <code>RACSignalBindBlock</code> 对原有的信号中的消息进行变换，生成一个新的信号：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Bind.png" alt=""></p><p><code>在原有的 RACSignal 对象上调用 -bind：方法传入 RACSignalBindBlock，图示中的右侧就是具体的执行过程，原信号在变换之后变成了新的蓝色的 RACSignal 对象。</code></p><p><code>RACSignalBindBlock</code> 可以简单理解为一个接受 <code>NSObject</code> 对象返回 <code>RACSignal</code> 对象的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef RACSignal * _Nullable (^RACSignalBindBlock)(id _Nullable value, BOOL *stop);</span><br></pre></td></tr></table></figure><p>其函数签名可以理解为 <code>id -&gt; RACSignal</code>，然而这种函数是无法直接对 <code>RACSignal</code> 对象进行变换的；不过通过 <code>-bind:</code> 方法就可以使用这种函数操作 <code>RACSignal</code>，其实现如下：</p><ol><li>将 <code>RACSignal</code> 对象『解包』出 <code>NSObject</code> 对象；</li><li>将 <code>NSObject</code> 传入 <code>RACSignalBindBlock</code> 返回 <code>RACSignal</code>。</li></ol><p>如果不考虑 <code>RACSignal</code> 会发出错误或者完成信号时，<code>-bind：</code>可以简化为下面简单的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        return [self subscribeNext:^(id x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            [bindingBlock(x, &amp;stop) subscribeNext:^(id x) &#123;</span><br><span class="line">                [subscriber sendNext:x];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>-subscribeNext:</code> 方法订阅当前信号，将信号中的状态解包，然后将原信号中的状态传入 <code>bindingBlock</code> 中并订阅返回的新的信号，将生成的新状态 <code>x</code> 传回原信号的订阅者。</p><p>这里通过两个简单的例子来了解 <code>-bind：</code>方法的作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendNext:@3];</span><br><span class="line">    [subscriber sendNext:@4];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        value = @(value.integerValue * value.integerValue);</span><br><span class="line">        return [RACSignal return:value];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;signal: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;bindSignal: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上面的代码直接使用了 <code>+return：</code>方法将 <code>value</code> 打包成了 <code>RACSignal *</code> 对象：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Before-After-Bind-RACSignal.png" alt=""></p><p><code>在 BindSignal 中的每一个数字其实都是由一个 RACSignal 包裹的，这里没有画出，在下一个例子中，可以清晰的看到他们的区别。</code></p><p>上图简要展示了变化前后的信号中包含的状态，在运行上述代码时，会在终端中打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">signal: 1</span><br><span class="line">signal: 2</span><br><span class="line">signal: 3</span><br><span class="line">signal: 4</span><br><span class="line">bindSignal: 1</span><br><span class="line">bindSignal: 4</span><br><span class="line">bindSignal: 9</span><br><span class="line">bindSignal: 16</span><br></pre></td></tr></table></figure><p>这是一个最简单的例子，直接使用 <code>-return:</code> 打包 <code>NSObject</code> 返回一个 <code>RACSignal</code>，接下来用一个更复杂的例子来帮助我们更好的了解 <code>-bind:</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        NSNumber *returnValue = @(value.integerValue * value.integerValue);</span><br><span class="line">        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; value.integerValue; i++) [subscriber sendNext:returnValue];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>下图相比上面例子中的图片更能精确的表现出 <code>-bind：</code>方法都做了什么：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Before-After-Bind-RACSignal-Complicated.png" alt=""></p><p>信号中原有的状态经过 <code>-bind:</code> 方法中传入 <code>RACSignalBindBlock</code> 的处理实际上返回了多个 <code>RACSignal</code>。</p><p>在源代码的注释中清楚地写出了方法的实现过程：</p><ol><li>订阅原信号中的值；</li><li>将原信号发出的值传入 <code>RACSignalBindBlock</code> 进行转换；</li><li>如果 <code>RACSignalBindBlock</code> 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 <code>subscriber</code>；</li><li>如果 <code>RACSignalBindBlock</code> 请求终止信号就会向原信号发出 <code>-sendCompleted</code> 消息；</li><li>当所有信号都完成时，会向订阅者发送 <code>-sendCompleted</code>；</li><li>无论何时，如果信号发出错误，都会向订阅者发送 <code>-sendError:</code> 消息。</li></ol><h2 id="信号的创建"><a href="#信号的创建" class="headerlink" title="信号的创建"></a>信号的创建</h2><p>信号的创建过程十分简单，<code>-createSignal:</code> 是推荐的创建信号的方法，方法其实只做了一次转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">RACDynamicSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line">return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改方法其实只是创建了一个 <code>RACDynamicSignal</code> 实例并保存了传入的 <code>didSubscribe</code> 代码块，在每次有订阅者订阅当前信号时，都会执行一遍，向订阅者发送消息。</p><h2 id="RACSignal-类簇"><a href="#RACSignal-类簇" class="headerlink" title="RACSignal 类簇"></a>RACSignal 类簇</h2><p>虽然 <code>-createSignal:</code> 的方法签名上返回的是 <code>RACSignal</code> 对象的实例，但是实际上这里返回的是 <code>RACDynamicSignal</code>，也就是 <code>RACSignal</code> 的子类；同样，在 <code>ReactiveCocoa</code> 中也有很多其他的 <code>RACSignal</code> 子类。</p><p>使用类簇的方式设计的 <code>RACSignal</code> 在创建实例时可能会返回 <code>RACDynamicSignal</code>、<code>RACEmptySignal</code>、<code>RACErrorSignal</code> 和 <code>RACReturnSignal</code> 对象：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subclasses.png" alt=""></p><p>其实这几种子类并没有对原有的 <code>RACSignal</code> 做出太大的改变，它们的创建过程也不是特别复杂，只需要调用 <code>RACSignal</code> 不同的类方法：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Instantiate-Object.png" alt=""></p><p><code>RACSignal</code> 只是起到了一个代理的作用，最后的实现过程还是会指向对应的子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACSignal *)error:(NSError *)error &#123;</span><br><span class="line">return [RACErrorSignal error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)empty &#123;</span><br><span class="line">return [RACEmptySignal empty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">return [RACReturnSignal return:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>RACReturnSignal</code> 的创建过程为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)return:(id)value &#123;</span><br><span class="line">RACReturnSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_value = value;</span><br><span class="line">return signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个信号的创建过程和 <code>RACDynamicSignal</code> 的初始化过程一样，都非常简单；只是将传入的 <code>value</code> 简单保存一下，在有其他订阅者 <code>-subscribe:</code> 时，向订阅者发送 <code>value：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">return [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">[subscriber sendNext:self.value];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACEmptySignal</code> 和 <code>RACErrorSignal</code> 的创建过程也异常的简单，只是对传入的数据进行简单的存储，然后在订阅时发送出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// RACEmptySignal</span><br><span class="line">+ (RACSignal *)empty &#123;</span><br><span class="line">return [[[self alloc] init] setNameWithFormat:@&quot;+empty&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">return [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RACErrorSignal</span><br><span class="line">+ (RACSignal *)error:(NSError *)error &#123;</span><br><span class="line">RACErrorSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_error = error;</span><br><span class="line">return signal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">return [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">[subscriber sendError:self.error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个创建过程的唯一区别就是一个发送的是『空值』，另一个是 <code>NSError</code> 对象。</p><h2 id="信号的订阅与信息的发送"><a href="#信号的订阅与信息的发送" class="headerlink" title="信号的订阅与信息的发送"></a>信号的订阅与信息的发送</h2><p><code>ReactiveCocoa</code> 中信号的订阅与信息的发送过程主要是由 <code>RACSubscriber</code> 类来处理的，而这也是信号的处理过程中最重要的一部分，这一小节会先分析整个工作流程，之后会深入代码的实现。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subcribe-Process.png" alt=""></p><p>在信号创建之后调用 <code>-subscribeNext:</code> 方法返回一个 <code>RACDisposable</code>，然而这不是这一流程关心的重点，在订阅过程中生成了一个 <code>RACSubscriber</code> 对象，向这个对象发送消息 <code>-sendNext:</code> 时，就会向所有的订阅者发送消息。</p><h3 id="信号的订阅"><a href="#信号的订阅" class="headerlink" title="信号的订阅"></a>信号的订阅</h3><p>信号的订阅与 <code>-subscribe:</code> 开头的一系列方法有关：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subscribe-Methods.png" alt=""></p><p>订阅者可以选择自己想要感兴趣的信息类型 <code>next/error/completed</code> 进行关注，并在对应的信息发生时调用 <code>block</code> 进行处理回调。</p><p>所有的方法其实只是对 <code>nextBlock</code>、<code>completedBlock</code> 以及 <code>errorBlock</code> 的组合，这里以其中最长的 <code>-subscribeNext:error:completed:</code> 方法的实现为例（也只需要介绍这一个方法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock &#123;</span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line">return [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到了传入的 <code>block</code> 之后，使用 <code>+subscriberWithNext:error:completed:</code> 初始化一个 <code>RACSubscriber</code> 对象的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line">RACSubscriber *subscriber = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">subscriber-&gt;_next = [next copy];</span><br><span class="line">subscriber-&gt;_error = [error copy];</span><br><span class="line">subscriber-&gt;_completed = [completed copy];</span><br><span class="line"></span><br><span class="line">return subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拿到这个对象之后，调用 <code>RACSignal</code> 的 <code>-subscribe:</code> 方法传入订阅者对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">NSCAssert(NO, @&quot;This method must be overridden by subclasses&quot;);</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACSignal</code> 类中其实并没有实现这个实例方法，需要在上文提到的四个子类对这个方法进行覆写，这里仅分析 <code>RACDynamicSignal</code> 中的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">    RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">        RACDisposable *innerDisposable = self.didSubscribe(subscriber);</span><br><span class="line">        [disposable addDisposable:innerDisposable];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [disposable addDisposable:schedulingDisposable];</span><br><span class="line">    </span><br><span class="line">    return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACPassthroughSubscriber</code> 就像它的名字一样，只是对上面创建的订阅者对象进行简单的包装，将所有的消息转发给内部的 <code>innerSubscriber</code>，也就是传入的 <code>RACSubscriber</code> 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithSubscriber:(id&lt;RACSubscriber&gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable &#123;</span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_innerSubscriber = subscriber;</span><br><span class="line">_signal = signal;</span><br><span class="line">_disposable = disposable;</span><br><span class="line"></span><br><span class="line">[self.innerSubscriber didSubscribeWithDisposable:self.disposable];</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接简化 <code>-subscribe:</code> 方法的实现，你可以看到一个看起来极为敷衍的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    return self.didSubscribe(subscriber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法只是执行了在创建信号时传入的 <code>RACSignalBindBlock</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;dispose&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>总而言之，信号的订阅过程就是初始化 <code>RACSubscriber</code> 对象，然后执行 <code>didSubscribe</code> 代码块的过程。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Principle-of-Subscribing-Signals.png" alt=""></p><h3 id="信息的发送"><a href="#信息的发送" class="headerlink" title="信息的发送"></a>信息的发送</h3><p>在 <code>RACSignalBindBlock</code> 中，订阅者可以根据自己的兴趣选择自己想要订阅哪种消息；我们也可以按需发送三种消息：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Subcription-Messages-Sending.png" alt=""></p><p>而现在只需要简单看一下这三个方法的实现，就能够明白信息的发送过程了（真是没啥好说的，不过为了凑字数完整性）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">void (^nextBlock)(id) = [self.next copy];</span><br><span class="line">if (nextBlock == nil) return;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-sendNext:</code> 只是将方法传入的值传入 <code>nextBlock</code> 再调用一次，并没有什么值得去分析的地方，而剩下的两个方法实现也差不多，会调用对应的 <code>block</code>，在这里就省略了。</p><h2 id="订阅的回收过程"><a href="#订阅的回收过程" class="headerlink" title="订阅的回收过程"></a>订阅的回收过程</h2><p>在创建信号时，我们向 <code>-createSignal:</code> 方法中传入了 <code>didSubscribe</code> 信号，这个 <code>block</code> 在执行结束时会返回一个 <code>RACDisposable</code> 对象，用于在订阅结束时进行必要的清理，同样也可以用于取消因为订阅创建的正在执行的任务。</p><p>而处理这些事情的核心类就是 <code>RACDisposable</code> 以及它的子类：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACDisposable-And-Subclasses.png" alt=""></p><h3 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h3><p>在继续分析讨论订阅的回收过程之前，笔者想先对 <code>RACDisposable</code> 进行简要的剖析和介绍：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACDisposable.png" alt=""></p><p>类 <code>RACDisposable</code> 是以 <code>_disposeBlock</code> 为核心进行组织的，几乎所有的方法以及属性其实都是对 <code>_disposeBlock</code> 进行的操作。</p><p><strong>关于 <code>_disposeBlock</code> 中的 self</strong></p><p><code>_disposeBlock</code> 是一个私有的指针变量，当 <code>void (^)(void)</code> 类型的 <code>block</code> 被传入之后都会转换成 CoreFoundation 中的类型并以 <code>void *</code> 的形式存入 <code>_disposeBlock</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (instancetype)disposableWithBlock:(void (^)(void))block &#123;</span><br><span class="line">return [[self alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block &#123;</span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (void *)CFBridgingRetain([block copy]); </span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇怪的是，<code>_disposeBlock</code> 中不止会存储代码块 <code>block</code>，还有可能存储桥接之后的 <code>self</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (__bridge void *)self;</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，刚开始看到可能会觉得比较奇怪，有两个疑问需要解决：</p><ol><li>为什么要提供一个 <code>-init</code> 方法来初始化 <code>RACDisposeable</code> 对象？</li><li>为什么要向 <code>_disposeBlock</code> 中传入当前对象？</li></ol><p>对于 <code>RACDisposable</code> 来说，虽然一个不包括 <code>_disposeBlock</code> 的对象没什么太多的意义，但是对于 <code>RACSerialDisposable</code> 等子类来说，却不完全是这样，因为 <code>RACSerialDisposable</code> 在 <code>-dispose</code> 时，并不需要执行 <code>disposeBlock</code>，这样就浪费了内存和 <code>CPU</code> 时间，但是同时我们需要一个合理的方法准确的判断当前对象的 <code>isDisposed</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)isDisposed &#123;</span><br><span class="line">return _disposeBlock == NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，使用向 <code>_disposableBlock</code> 中传入 <code>NULL</code> 的方式来判断 <code>isDisposed</code>; 在 <code>-init</code> 调用时传入 <code>self</code> 而不是 <code>NULL</code> 防止状态被误判，这样就在不引入其他实例变量、增加对象的设计复杂度的同时，解决了这两个问题。</p><h4 id="dispose-方法的实现"><a href="#dispose-方法的实现" class="headerlink" title="-dispose: 方法的实现"></a>-dispose: 方法的实现</h4><p>这个只有不到 20 行的 方法已经是整个 <code>RACDisposable</code> 类中最复杂的方法了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)dispose &#123;</span><br><span class="line">void (^disposeBlock)(void) = NULL;</span><br><span class="line"></span><br><span class="line">while (YES) &#123;</span><br><span class="line">void *blockPtr = _disposeBlock;</span><br><span class="line">if (OSAtomicCompareAndSwapPtrBarrier(blockPtr, NULL, &amp;_disposeBlock)) &#123;</span><br><span class="line">if (blockPtr != (__bridge void *)self) &#123;</span><br><span class="line">disposeBlock = CFBridgingRelease(blockPtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (disposeBlock != nil) disposeBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是其实它的实现也没有复杂到哪里去，从 <code>_disposeBlock</code> 实例变量中调用 <code>CFBridgingRelease</code> 取出一个 <code>disposeBlock</code>，然后执行这个 <code>block</code>，整个方法就结束了。</p><h3 id="RACSerialDisposable"><a href="#RACSerialDisposable" class="headerlink" title="RACSerialDisposable"></a>RACSerialDisposable</h3><p><code>RACSerialDisposable</code> 是一个用于持有 <code>RACDisposable</code> 的容器，它一次只能持有一个 <code>RACDisposable</code> 的实例，并可以原子地换出容器中保存的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)swapInDisposable:(RACDisposable *)newDisposable &#123;</span><br><span class="line">RACDisposable *existingDisposable;</span><br><span class="line">BOOL alreadyDisposed;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">alreadyDisposed = _disposed;</span><br><span class="line">if (!alreadyDisposed) &#123;</span><br><span class="line">existingDisposable = _disposable;</span><br><span class="line">_disposable = newDisposable;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">if (alreadyDisposed) &#123;</span><br><span class="line">[newDisposable dispose];</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return existingDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全的 <code>RACSerialDisposable</code> 使用 <code>pthred_mutex_t</code> 互斥锁来保证在访问关键变量时不会出现线程竞争问题。</p><p><code>-dispose</code> 方法的处理也十分简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispose &#123;</span><br><span class="line">RACDisposable *existingDisposable;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">if (!_disposed) &#123;</span><br><span class="line">existingDisposable = _disposable;</span><br><span class="line">_disposed = YES;</span><br><span class="line">_disposable = nil;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">[existingDisposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用锁保证线程安全，并在内部的 <code>_disposable</code> 换出之后在执行 <code>-dispose</code> 方法对订阅进行处理。</p><h3 id="RACCompoundDisposable"><a href="#RACCompoundDisposable" class="headerlink" title="RACCompoundDisposable"></a>RACCompoundDisposable</h3><p>与 <code>RACSerialDisposable</code> 只负责一个 <code>RACDisposable</code> 对象的释放不同；<code>RACCompoundDisposable</code> 同时负责多个 <code>RACDisposable</code> 对象的释放。</p><p>相比于只管理一个 <code>RACDisposable</code> 对象的 <code>RACSerialDisposable</code>，<code>RACCompoundDisposable</code> 由于管理多个对象，其实现更加复杂，而且为了性能和内存占用之间的权衡，其实现方式是通过持有两个实例变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface RACCompoundDisposable () &#123;</span><br><span class="line">    ...</span><br><span class="line">    RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line"></span><br><span class="line">    CFMutableArrayRef _disposables;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象持有的 <code>RACDisposable</code> 不超过 <code>RACCompoundDisposableInlineCount</code> 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCompoundDisposable.png" alt=""></p><p><code>RACCompoundDisposable</code> 在使用 <code>-initWithDisposables:</code> 初始化时，会初始化两个 <code>RACDisposable</code> 的位置用于加速销毁订阅的过程，同时为了不浪费内存空间，在默认情况下只占用两个位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithDisposables:(NSArray *)otherDisposables &#123;</span><br><span class="line">self = [self init];</span><br><span class="line"></span><br><span class="line">[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">self-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line">if (index == RACCompoundDisposableInlineCount - 1) *stop = YES;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">if (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line">CFRange range = CFRangeMake(RACCompoundDisposableInlineCount, (CFIndex)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line">CFArrayAppendArray(_disposables, (__bridge CFArrayRef)otherDisposables, range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的 <code>otherDisposables</code> 多于 <code>RACCompoundDisposableInlineCount</code>，就会创建一个新的 <code>CFMutableArrayRef</code> 引用，并将剩余的 <code>RACDisposable</code> 全部传入这个数组中。</p><p>在 <code>RACCompoundDisposable</code> 中另一个值得注意的方法就是 <code>-addDisposable:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line">if (disposable == nil || disposable.disposed) return;</span><br><span class="line"></span><br><span class="line">BOOL shouldDispose = NO;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line">if (_disposed) &#123;</span><br><span class="line">shouldDispose = YES;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">if (_inlineDisposables[i] == nil) &#123;</span><br><span class="line">_inlineDisposables[i] = disposable;</span><br><span class="line">goto foundSlot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_disposables == NULL) _disposables = RACCreateDisposablesArray();</span><br><span class="line">CFArrayAppendValue(_disposables, (__bridge void *)disposable);</span><br><span class="line">foundSlot:;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">if (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在向 <code>RACCompoundDisposable</code> 中添加新的 <code>RACDisposable</code> 对象时，会先尝试在 <code>_inlineDisposables</code> 数组中寻找空闲的位置，如果没有找到，就会加入到 <code>_disposables</code> 中；但是，在添加 <code>RACDisposable</code> 的过程中也难免遇到当前 <code>RACCompoundDisposable</code> 已经 <code>dispose</code> 的情况，而这时就会直接 <code>-dispose</code> 刚刚加入的对象。</p><h2 id="订阅的销毁过程"><a href="#订阅的销毁过程" class="headerlink" title="订阅的销毁过程"></a>订阅的销毁过程</h2><p>在了解了 <code>ReactiveCocoa</code> 中与订阅销毁相关的类，我们就可以继续对 <code>-bind:</code> 方法的分析了，之前在分析该方法时省略了 <code>-bind:</code> 在执行过程中是如何处理订阅的清理和销毁的，所以会省略对于正常值和错误的处理过程，首先来看一下简化后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACSignalBindBlock bindingBlock = block();</span><br><span class="line">        __block volatile int32_t signalCount = 1;</span><br><span class="line">        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">        void (^completeSignal)(RACDisposable *) = ...</span><br><span class="line">        void (^addSignal)(RACSignal *) = ...</span><br><span class="line"></span><br><span class="line">        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">        [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line">        RACDisposable *bindingDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">            BOOL stop = NO;</span><br><span class="line">            id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">            if (signal != nil) addSignal(signal);</span><br><span class="line">            if (signal == nil || stop) &#123;</span><br><span class="line">                [selfDisposable dispose];</span><br><span class="line">                completeSignal(selfDisposable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line">            completeSignal(selfDisposable);</span><br><span class="line">        &#125;];</span><br><span class="line">        selfDisposable.disposable = bindingDisposable;</span><br><span class="line">        return compoundDisposable;</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在简化的代码中，订阅的清理是由一个 <code>RACCompoundDisposable</code> 的实例负责的，向这个实例中添加 <code>RACSerialDisposable</code> 以及 <code>RACDisposable</code> 对象，并在 <code>RACCompoundDisposable</code> 销毁时销毁。</p><p><code>completeSignal</code> 和 <code>addSignal</code> 两个 <code>block</code> 主要负责处理新创建信号的清理工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    if (OSAtomicDecrement32Barrier(&amp;signalCount) == 0) &#123;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        [compoundDisposable dispose];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">    OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line">    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">    [compoundDisposable addDisposable:selfDisposable];</span><br><span class="line">    RACDisposable *disposable = [signal completed:^&#123;</span><br><span class="line">        completeSignal(selfDisposable);</span><br><span class="line">    &#125;];</span><br><span class="line">    selfDisposable.disposable = disposable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先通过一个例子来看一下 <code>-bind:</code> 方法调用之后，订阅是如何被清理的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendNext:@2];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;Original Signal Dispose.&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    return ^(NSNumber *value, BOOL *stop) &#123;</span><br><span class="line">        NSNumber *returnValue = @(value.integerValue);</span><br><span class="line">        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            for (NSInteger i = 0; i &lt; value.integerValue; i++) [subscriber sendNext:returnValue];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                NSLog(@&quot;Binding Signal Dispose.&quot;);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;];</span><br><span class="line">[bindSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在每个订阅创建以及所有的值发送之后，订阅就会被就地销毁，调用 <code>disposeBlock</code>，并从 <code>RACCompoundDisposable</code> 实例中移除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">Binding Signal Dispose.</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Binding Signal Dispose.</span><br><span class="line">Original Signal Dispose.</span><br></pre></td></tr></table></figure><p>原订阅的销毁时间以及绑定信号的控制是由 <code>SignalCount</code> 控制的，其表示 <code>RACCompoundDisposable</code> 中的 <code>RACSerialDisposable</code> 实例的个数，在每次有新的订阅被创建时都会向 <code>RACCompoundDisposable</code> 加入一个新的 <code>RACSerialDisposable</code>，并在订阅发送结束时从数组中移除，整个过程用图示来表示比较清晰：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSignal-Bind-Disposable.png" alt=""></p><p>紫色的 <code>RACSerialDisposable</code> 为原订阅创建的对象，灰色的为新信号订阅的对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RAC</code> 中绝大多数的方法都相当简洁，行数并不多，代码的组织方式很多，值得大家去阅读与学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ReactiveCocoa-与信号&quot;&gt;&lt;a href=&quot;#ReactiveCocoa-与信号&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa 与信号&quot;&gt;&lt;/a&gt;ReactiveCocoa 与信号&lt;/h2&gt;&lt;p&gt;&lt;code&gt;RAC&lt;
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>iOS 版本兼容与判断</title>
    <link href="https://huangzhifei.github.io/2019/03/22/Objective-C/2019/iOS%20%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E4%B8%8E%E5%88%A4%E6%96%AD/"/>
    <id>https://huangzhifei.github.io/2019/03/22/Objective-C/2019/iOS 版本兼容与判断/</id>
    <published>2019-03-22T09:41:06.000Z</published>
    <updated>2020-01-05T02:55:03.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直接获取系统版本"><a href="#直接获取系统版本" class="headerlink" title="直接获取系统版本"></a>直接获取系统版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSString *version = [UIDevice currentDevice].systemVersion;</span><br><span class="line">if (version.doubleValue &gt;= 9.0) &#123;</span><br><span class="line">    // 针对 9.0 以上的iOS系统进行处理</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 针对 9.0 以下的iOS系统进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-Foundation-框架版本号"><a href="#通过-Foundation-框架版本号" class="headerlink" title="通过 Foundation 框架版本号"></a>通过 Foundation 框架版本号</h2><p>通过 NSFoundationVersionNumber 判断API 的兼容性。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义文件路径：<code>#import&lt;Foundation/NSObjecRuntime.h&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define NSFoundationVersionNumber10_0397.40</span><br><span class="line">#define NSFoundationVersionNumber10_1425.00</span><br><span class="line">#define NSFoundationVersionNumber10_1_1425.00</span><br><span class="line">#define NSFoundationVersionNumber10_1_2425.00</span><br><span class="line">#define NSFoundationVersionNumber10_1_3425.00</span><br><span class="line">#define NSFoundationVersionNumber10_1_4425.00</span><br><span class="line">#define NSFoundationVersionNumber10_2462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_1462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_2462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_3462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_4462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_5462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_6462.00</span><br><span class="line">#define NSFoundationVersionNumber10_2_7462.70</span><br><span class="line">#define NSFoundationVersionNumber10_2_8462.70</span><br></pre></td></tr></table></figure><h2 id="系统宏"><a href="#系统宏" class="headerlink" title="系统宏"></a>系统宏</h2><h3 id="IPHONE-OS-VERSION-MAX-ALLOWED"><a href="#IPHONE-OS-VERSION-MAX-ALLOWED" class="headerlink" title="__IPHONE_OS_VERSION_MAX_ALLOWED"></a>__IPHONE_OS_VERSION_MAX_ALLOWED</h3><p>当前开发环境版本（当前开发环境的系统SDK版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_8_0</span><br><span class="line">// 当前开发环境版本在iOS8.0及以上则编译此部分代码</span><br><span class="line">#else</span><br><span class="line">// 如果低于iOS8.0则编译此部分代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>注意：这里最好不要这样去判定一个方法或属性是否可用！此处在编译后已经确定是否包含此部分代码，因为它依赖的是当前的开发环境，而不是当前系统环境，它运行在编译时而不是运行时，所以经过打包后，此处就不会变了，在一些特殊情况下会造成严重问题！慎用！！</p><h3 id="IPHONE-OS-VERSION-MIN-REQUIRED"><a href="#IPHONE-OS-VERSION-MIN-REQUIRED" class="headerlink" title="__IPHONE_OS_VERSION_MIN_REQUIRED"></a>__IPHONE_OS_VERSION_MIN_REQUIRED</h3><p>系统最低支持版本（也就是当前项目选择的最低版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= __IPHONE_8_0</span><br><span class="line">// 如果选择(iOS Deployment Target)的最低支持版本在iOS8.0及以上才可以使用</span><br><span class="line">- (void)execute;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="系统版本宏"><a href="#系统版本宏" class="headerlink" title="系统版本宏"></a>系统版本宏</h2><p>系统版本宏可以判断当前系统版本是否是大于等于某个版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define __IPHONE_8_0      80000</span><br><span class="line">#define __IPHONE_8_1      80100</span><br><span class="line">#define __IPHONE_8_2      80200</span><br><span class="line">#define __IPHONE_8_3      80300</span><br><span class="line">#define __IPHONE_8_4      80400</span><br><span class="line">#define __IPHONE_9_0      90000</span><br><span class="line">#define __IPHONE_9_1      90100</span><br><span class="line">#define __IPHONE_9_2      90200</span><br><span class="line">#define __IPHONE_9_3      90300</span><br><span class="line">#define __IPHONE_10_0    100000</span><br><span class="line">#define __IPHONE_10_1    100100</span><br><span class="line">#define __IPHONE_10_2    100200</span><br><span class="line">#define __IPHONE_10_3    100300</span><br><span class="line">#define __IPHONE_11_0    110000</span><br><span class="line">#define __IPHONE_11_1    110100</span><br><span class="line">#define __IPHONE_11_2    110200</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifdef __IPHONE_8_0</span><br><span class="line">// 系统版本大于 iOS8.0 执行</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef __IPHONE_10_0</span><br><span class="line">// 系统版本大于 iOS10.0 执行</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="available-运行时检查"><a href="#available-运行时检查" class="headerlink" title="@available 运行时检查"></a>@available 运行时检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (@available(iOS 11, *)) &#123; // &gt;= 11</span><br><span class="line">    NSLog(@&quot;iOS 11&quot;);</span><br><span class="line">&#125; else if (@available(iOS 10, *)) &#123; //&gt;= 10</span><br><span class="line">    NSLog(@&quot;iOS 10&quot;);</span><br><span class="line">&#125; else &#123; // &lt; 10</span><br><span class="line">    NSLog(@&quot; &lt; iOS 10&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;直接获取系统版本&quot;&gt;&lt;a href=&quot;#直接获取系统版本&quot; class=&quot;headerlink&quot; title=&quot;直接获取系统版本&quot;&gt;&lt;/a&gt;直接获取系统版本&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>RACSubject的用法</title>
    <link href="https://huangzhifei.github.io/2019/03/20/Objective-C/ReactiveObjc/RACSubject%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://huangzhifei.github.io/2019/03/20/Objective-C/ReactiveObjc/RACSubject的用法/</id>
    <published>2019-03-20T13:52:21.000Z</published>
    <updated>2020-01-05T02:55:03.371Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>ReactiveCocoa</code> 中除了不可变的信号 <code>RACSignal</code>，也有用于桥接非 <code>RAC</code> 代码到 <code>ReactiveCocoa</code> 世界的『可变』信号 <code>RACSubject</code>。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Mutable-RACSignal—RACSubject.png" alt=""></p><p><code>RACSubject</code> 到底是什么？根据其字面意思，可以将其理解为一个可以订阅的主题，我们在订阅主题之后，向主题发送新的消息时，所有的订阅者都会接收到最新的消息。</p><p>但是这么解释确实有点羞涩，也不易于理解，<code>ReactiveCocoa</code> 团队对 <code>RACSubject</code> 的解释是 <code>RACSubject</code> 其实就是一个可以手动控制的信号。</p><h2 id="RACSubject-简介"><a href="#RACSubject-简介" class="headerlink" title="RACSubject 简介"></a>RACSubject 简介</h2><p><code>RACSubject</code> 是 <code>RACSignal</code> 的子类，与 <code>RACSignal</code> 以及 <code>RACSequence</code> 有着众多的类簇不同，<code>RACSubject</code> 在整个工程中并没有多少子类，不过在大多数情况下，我们也只会使用 <code>RACSubject</code> 自己或者 <code>RACReplaySubject</code>。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSubject - Subclasses.png" alt=""></p><p>相比于 <code>RACSignal</code> 丰富的头文件，<code>RACSignal</code> 对外的接口并没有提供太多的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface RACSubject : RACSignal &lt;RACSubscriber&gt;</span><br><span class="line"></span><br><span class="line">+ (instancetype)subject;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在笔者看来它与 <code>RACSignal</code> 最大的不同就是：<code>RACSubject</code> 实现了 <code>RACSubscriber</code> 协议，也就是下面的这些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@protocol RACSubscriber &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(nullable id)value;</span><br><span class="line">- (void)sendError:(nullable NSError *)error;</span><br><span class="line">- (void)sendCompleted;</span><br><span class="line">- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们并不能在一个 <code>RACSignal</code> 对象上执行这些方法，只能在创建信号的 <code>block</code> 里面遵循 <code>RACSubscriber</code> 协议的对象发送新的值或者错误，这也是 <code>RACSubject</code> 和父类最大的不同：在 <code>RACSubject</code> 实例初始化之后，也可以通过这个实例向所有的订阅者发送消息。</p><h2 id="冷信号与热信号"><a href="#冷信号与热信号" class="headerlink" title="冷信号与热信号"></a>冷信号与热信号</h2><p>提到 RACSubject 就不得不提 ReactiveCocoa 中的另一对概念，冷信号和热信号。</p><p>对于冷热信号概念，我们借用 Rx 中的描述：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Hot-Signal-And-Cold-Signal.png" alt=""></p><p>冷信号是被动的，只会在订阅时向订阅者发送通知；</p><p>热信号是主动的，它会在任意时间发出通知，与订阅者的订阅时间无关。</p><p>也就是说冷信号所有的订阅者会在订阅时收到完全相同的序列，而订阅热信号之后，只会收到在订阅之后发出的序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">热信号的订阅者能否收到消息取决于订阅的时间。</span><br></pre></td></tr></table></figure><p>热信号在我们生活中很多的例子，比如订阅杂志时并不会把之前所有的期刊都送到我们手中，只会接收到订阅之后的期刊，而对于冷信号的话，举个不恰当的例子，每一年的高考生在订阅高考之后，收到往年所有的试卷，并在高考之后会取消订阅。</p><h2 id="热信号-RACSubject"><a href="#热信号-RACSubject" class="headerlink" title="热信号 RACSubject"></a>热信号 RACSubject</h2><p>在 <code>ReactiveCocoa</code> 中，我们使用 <code>RACSignal</code> 来表示冷信号，也就是每一个订阅者在订阅信号时都会收到完整的序列；<code>RACSubject</code> 用于表示热信号，订阅者接收到多少值取决于它订阅的时间。</p><p>前面的文章中已经对 <code>RACSignal</code> 冷信号有了很多的介绍，这里也就不会多说了；这一小节主要的内容是想通过一个例子，简单展示 <code>RACSubject</code> 的订阅者收到的内容与订阅时间的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">// Subscriber 1</span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;1st Sub: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line"></span><br><span class="line">// Subscriber 2</span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;2nd Sub: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@2];</span><br><span class="line"></span><br><span class="line">// Subscriber 3</span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;3rd Sub: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@3];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure><p>这里以图的方式来展示整个订阅与订阅者接收消息的过程：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Track-RACSubject-Subscription-Process.png" alt=""></p><p>从图中我们可以清楚的看到，几个订阅者根据<strong>订阅时间</strong>的不同收到了不同的数字序列，<code>RACSubject</code> 是<strong>时间相关</strong>的，它在发送消息时只会向已订阅的订阅者推送消息。</p><h2 id="RACSubject-的实现"><a href="#RACSubject-的实现" class="headerlink" title="RACSubject 的实现"></a>RACSubject 的实现</h2><p><code>RACSubject</code> 的实现并不复杂，它『可变』的特性都来源于持有的订阅者数组 <code>subscribers</code>，在每次执行 <code>subscribeNext:error:completed:</code> 一类便利方法时，都会将传入的 <code>id&lt;RACSubscriber&gt;</code> 对象加入数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">NSMutableArray *subscribers = self.subscribers;</span><br><span class="line">@synchronized (subscribers) &#123;</span><br><span class="line">[subscribers addObject:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">@synchronized (subscribers) &#123;</span><br><span class="line">NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">return obj == subscriber;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">if (index != NSNotFound) [subscribers removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅的过程分为三个部分：</p><p>1、初始化一个 <code>RACPassthroughSubscriber</code> 实例；</p><p>2、将 <code>subscriber</code> 加入 <code>RACSubject</code> 持有的数组中；</p><p>3、创建一个 <code>RACDisposable</code> 对象，在当前 <code>subscriber</code> 销毁时，将自身从数组中移除。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Send-Subscibe-to-RACSubject.png" alt=""></p><p><code>-subscribe:</code> 将所有遵循 <code>RACSubscriber</code> 协议的对象全部加入当前 <code>RACSubject</code> 持有的数组 <code>subscribers</code> 中。</p><p>在上一节的例子中，我们能对 <code>RACSubject</code> 发送 <code>-sendNext:</code> 等消息也都取决于它实现了 <code>RACSubscriber</code> 协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendError:(NSError *)error &#123;</span><br><span class="line">[self.disposable dispose];</span><br><span class="line"></span><br><span class="line">[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendCompleted &#123;</span><br><span class="line">[self.disposable dispose];</span><br><span class="line"></span><br><span class="line">[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACSubject</code> 会在自身接受到这些方法时，下发给持有的全部的 <code>subscribers</code>。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Send-Messages-to-RACSubject.png" alt=""></p><p>代码中的 <code>-enumerateSubscribersUsingBlock:</code> 只是一个使用 <code>for</code> 循环遍历 <code>subscribers</code> 的安全方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123;</span><br><span class="line">NSArray *subscribers;</span><br><span class="line">@synchronized (self.subscribers) &#123;</span><br><span class="line">subscribers = [self.subscribers copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123;</span><br><span class="line">block(subscriber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACSubject</code> 就是围绕一个 <code>NSMutableArray</code> 数组实现的，实现还是非常简单的，只是在需要访问 <code>subscribers</code> 的方法中使用 <code>@synchronized</code> 避免线程竞争。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface RACSubject ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) NSMutableArray *subscribers;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>RACSubject</code> 提供的初始化类方法 <code>+subject</code> 也只是初始化了几个成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (instancetype)subject &#123;</span><br><span class="line">return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self == nil) return nil;</span><br><span class="line"></span><br><span class="line">_disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">_subscribers = [[NSMutableArray alloc] initWithCapacity:1];</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，对于 RACSubject 的分析就结束了，接下来会分析更多的子类。</p><h2 id="RACBehaviorSubject-与-RACReplaySubject"><a href="#RACBehaviorSubject-与-RACReplaySubject" class="headerlink" title="RACBehaviorSubject 与 RACReplaySubject"></a>RACBehaviorSubject 与 RACReplaySubject</h2><p>这一节会介绍 <code>RACSubject</code> 的两个子类 <code>RACBehaviorSubject</code> 和 <code>RACReplaySubject</code>，前者在订阅时会向订阅者发送最新的消息，后者在订阅之后可以重新发送之前的所有消息序列。</p><h3 id="RACBehaviorSubject"><a href="#RACBehaviorSubject" class="headerlink" title="RACBehaviorSubject"></a>RACBehaviorSubject</h3><p>先来介绍两者中实现比较简单的 RACBehaviorSubject，它在内部会保存一个 currentValue 对象，也就是最后一次发送的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface RACBehaviorSubject ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) id currentValue;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在每次执行 <code>-sendNext:</code> 时，都会对 <code>RACBehaviorSubject</code> 中保存的 <code>currentValue</code> 进行更新，并使用父类的 <code>-sendNext：</code>方法，向所有的订阅者发送最新的消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">self.currentValue = value;</span><br><span class="line">[super sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACBehaviorSubject</code> 最重要的特性就是在订阅时，向最新的订阅者发送之前的消息，这是通过覆写 <code>-subscribe:</code> 方法实现的。</p><p>在调用子类的 <code>-subscribe:</code> 方法之后，会在 <code>subscribe</code> 对象上执行 <code>-sendNext：</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [super subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">[subscriber sendNext:self.currentValue];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[schedulingDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，通过一个简单的例子来演示 <code>RACBehaviorSubject</code> 到底是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACBehaviorSubject *subject = [RACBehaviorSubject subject];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;1st Sub: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;2nd Sub: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@2];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;3rd Sub: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@3];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure><p>上面的代码其实与 <code>RACSubject</code> 一节中的代码差不多，只将 <code>RACSubject</code> 转换成了 <code>RACBehaviorSubject</code> 对象。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Track-RACBehaviorSubject-Subscription-Process.png" alt=""></p><p>在每次订阅者订阅 <code>RACBehaviorSubject</code> 之后，都会向该订阅者发送最新的消息，这也就是 <code>RACBehaviorSubject</code> 最重要的行为。</p><p><code>RACBehaviorSubject</code> 有一个用于创建包含默认值的类方法 <code>+behaviorSubjectWithDefaultValue:</code>，如果将上面的第一行代码改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACBehaviorSubject *subject = [RACBehaviorSubject behaviorSubjectWithDefaultValue:@0];</span><br></pre></td></tr></table></figure><p>那么在第一个订阅者刚订阅 RACBehaviorSubject 时就会收到 @0 对象。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Track-RACBehaviorSubject-Subscription-Process-With-Default-Value.png" alt=""></p><h3 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h3><p><code>RACReplaySubject</code> 相当于一个自带 <code>buffer</code> 的 <code>RACBehaviorSubject</code>，它可以在每次有新的订阅者订阅之后发送之前的全部消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface RACReplaySubject ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) NSUInteger capacity;</span><br><span class="line">@property (nonatomic, strong, readonly) NSMutableArray *valuesReceived;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>实现的方式是通过持有一个 <code>valuesReceived</code> 的数组和能够存储的对象的上限 <code>capacity</code>，默认值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const NSUInteger RACReplaySubjectUnlimitedCapacity = NSUIntegerMax;</span><br></pre></td></tr></table></figure><p>当然你可以用 <code>+replaySubjectWithCapacity:</code> 初始化一个其它大小的 <code>RACReplaySubject</code> 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (instancetype)replaySubjectWithCapacity:(NSUInteger)capacity &#123;</span><br><span class="line">return [(RACReplaySubject *)[self alloc] initWithCapacity:capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCapacity:(NSUInteger)capacity &#123;</span><br><span class="line">self = [super init];</span><br><span class="line"></span><br><span class="line">_capacity = capacity;</span><br><span class="line">_valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次调用 <code>-sendNext:</code> 方法发送消息时，都会将其加入 <code>valuesReceived</code> 数组中，并踢出之前的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">[self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</span><br><span class="line">[super sendNext:value];</span><br><span class="line"></span><br><span class="line">if (self.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; self.valuesReceived.count &gt; self.capacity) &#123;</span><br><span class="line">[self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的有两点，一是对 <code>valuesReceived</code> 的数组的操作必须使用 <code>@synchronized</code> 加锁；第二，如果 <code>value</code> 为空的话，也需要将其转换成 <code>RACTupleNil.tupleNil</code> 对象进行保存。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Send-Messages-to-RACReplaySubject.png" alt=""></p><p><code>-sendError:</code> 和 <code>-sendCompleted</code> 方法都会标记对应 <code>flag</code>，即 <code>hasCompleted</code> 和 <code>hasError</code>，这里就不介绍了；同样的，<code>RACReplaySubject</code> 也覆写了 <code>-subscribe:</code> 方法，在每次有订阅者订阅时重新发送所有的序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">for (id value in self.valuesReceived) &#123;</span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">if (self.hasCompleted) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; else if (self.hasError) &#123;</span><br><span class="line">[subscriber sendError:self.error];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [super subscribe:subscriber];</span><br><span class="line">[compoundDisposable addDisposable:subscriptionDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:schedulingDisposable];</span><br><span class="line"></span><br><span class="line">return compoundDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仍然使用上一节中的例子来展示 <code>RACReplaySubject</code> 是如何工作的，只修改第一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACReplaySubject *subject = [RACReplaySubject subject];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;1st Subscriber: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@1];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;2nd Subscriber: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@2];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;3rd Subscriber: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject sendNext:@3];</span><br><span class="line">[subject sendCompleted];</span><br></pre></td></tr></table></figure><p>运行这段代码之后，会得到如下图的结果：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Track-RACReplaySubject-Subscription-Process.png" alt=""></p><p>所有订阅 <code>RACReplaySubject</code> 的对象（默认行为）都能获得完整的序列，而这个特性在与 <code>RACMulticastConnection</code> 一起使用也有着巨大威力，我们会在之后的文章中介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>RACSubject</code> 在 <code>RACSignal</code> 对象之上进行了简单的修改，将原有的冷信号改造成了热信号，将不可变变成了可变。</p><p>虽然 <code>RACSubject</code> 的实现并不复杂，只是存储了一个遵循 <code>RACSubscriber</code> 协议的对象列表以及所有的消息，但是在解决实际问题时却能够很好地解决很多与网络操作相关的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;ReactiveCocoa&lt;/code&gt; 中除了不可变的信号 &lt;code&gt;RACSignal&lt;/code&gt;，也有用于桥接非 &lt;code&gt;RAC&lt;/code&gt; 代码到 &lt;code&gt;ReactiveCocoa&lt;/code&gt; 世界的『可变』信号 &lt;code&gt;RAC
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>RACCommand的用法</title>
    <link href="https://huangzhifei.github.io/2019/03/18/Objective-C/ReactiveObjc/RACCommand%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://huangzhifei.github.io/2019/03/18/Objective-C/ReactiveObjc/RACCommand的用法/</id>
    <published>2019-03-18T15:29:54.000Z</published>
    <updated>2020-01-05T02:55:03.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><p>RACCommand 在 ReactiveObjc 中是比较复杂的类，对于大多数人尤其是初学者并不会经常使用他。</p><p>在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/What-is-RACCommand.png" alt=""></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RACCommand 与 RACSignal 等元素是不同的，RACCommand 并不表示数据流，可以看他的继承关系，他是直接继承自 NSObject，但是看他提供的 API，他是可以用来创建和订阅用于响应某些事件的信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface RACCommand&lt;__contravariant InputType, __covariant ValueType&gt; : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>他是一个用于管理 RACSignal 的创建与订阅的类。</p><p>在 ReactiveObjc 中对 RACCommand 有这样一段直白的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A command,represented by the RACCommand class,creates and subscribes to a signal in response to some action.</span><br><span class="line"></span><br><span class="line">This makes it easy to perform side-effecting(副作用) work as the user interacts with the app.</span><br></pre></td></tr></table></figure><p>在用于与 UIKit 组件进行交互或执行包含副作用的操作时，RACCommand 能够帮助我们更快的处理并且响应任务，减少编码以及工程的复杂度。</p><h3 id="初始化和执行"><a href="#初始化和执行" class="headerlink" title="初始化和执行"></a>初始化和执行</h3><p>在 - (instancetype)initWithSignalBlock: 方法的签名上，你可以看到在每次 RACCommand 初始化时都会传入一个类型为 (RACSignal<valuetype> * (^)(InputType _Nullable input))signalBlock: </valuetype></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br></pre></td></tr></table></figure><p>输入为 InputType 返回值为 RACSignal<valuetype> *, 而 InputType 也就是在调用 - excute: 方法传入的对象：</valuetype></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(nullable InputType)input;</span><br></pre></td></tr></table></figure><p>这就是 RACCommand 将外部变量（或副作用）传入 ReactiveObjc 内部的方法，你可以理解为 RACCommand 将外部的变量 InputType 转换成了使用 RACSignal 包裹的 ValueType 对象。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execute-For-RACCommand.png" alt=""></p><p>我们以下面的代码为例子，先来看一下 RACCommand 是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) &#123;</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        NSInteger integer = [input integerValue];</span><br><span class="line">        for (NSInteger i = 0; i &lt; integer; i++) &#123;</span><br><span class="line">            [subscriber sendNext:@(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;command: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[command execute:@1];</span><br><span class="line"></span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.1</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@2];</span><br><span class="line">                                    &#125;];</span><br><span class="line">                                    </span><br><span class="line">[RACScheduler.mainThreadScheduler afterDelay:0.2</span><br><span class="line">                                    schedule:^&#123;</span><br><span class="line">                                        [command execute:@3];</span><br><span class="line">                                    &#125;];</span><br></pre></td></tr></table></figure><p>上面的代码打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command: 0</span><br><span class="line">command: 0</span><br><span class="line">command: 1</span><br><span class="line">command: 0</span><br><span class="line">command: 1</span><br><span class="line">command: 2</span><br></pre></td></tr></table></figure><p>每次 executionSignals 中发送了新的信号时，switchToLatest 方法返回的信号都会订阅这个最新的信号，这里也就保证了每次都会打印出最新的信号中的值。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Multiple-Executes.png" alt=""></p><p>在上面的代码中还有最后一个问题，为什么要使用 RACScheduler.mainThreadScheduler 延迟调用之后的 - execute: 方法？</p><p>由于在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次的操作，否则就会返回错误信号 RACErrorSignal，这些错误可以通过订阅 command.errors 获取。</p><p>所以如果你使用如下的方式执行几次 - execute: 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[command execute:@1];</span><br><span class="line">[command execute:@2];</span><br><span class="line">[command execute:@3];</span><br></pre></td></tr></table></figure><p>最终就只打印 command: 0</p><h3 id="最重要的内部“信号”"><a href="#最重要的内部“信号”" class="headerlink" title="最重要的内部“信号”"></a>最重要的内部“信号”</h3><p>RACCommand 中最重要的内部信号就是 addedExecutionSignalsSubject:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@property (nonatomic, strong, readonly) RACSubject *addedExecutionSignalsSubject;</span><br></pre></td></tr></table></figure><p>这个 RACSubject 对象通过各种操作衍生了几乎所有 RACCommand 中的其他信号。</p><p>既然 addedExecutionSignalsSubject 是一个 RACSubject，它不能在创建时预设好对订阅者发送的消息，它会在哪里接受数据并推送给订阅者呢？答案就在 -execute: 方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACSignal *)execute:(id)input &#123;</span><br><span class="line">BOOL enabled = [[self.immediateEnabled first] boolValue];</span><br><span class="line">if (!enabled) &#123;</span><br><span class="line">NSError *error = [NSError errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@&#123;</span><br><span class="line">NSLocalizedDescriptionKey: NSLocalizedString(@&quot;The command is disabled and cannot be executed&quot;, nil),</span><br><span class="line">RACUnderlyingCommandErrorKey: self</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">return [RACSignal error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACSignal *signal = self.signalBlock(input);</span><br><span class="line">RACMulticastConnection *connection = [[signal</span><br><span class="line">subscribeOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">multicast:[RACReplaySubject subject]];</span><br><span class="line"></span><br><span class="line">[self.addedExecutionSignalsSubject sendNext:connection.signal];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br><span class="line">return [connection.signal setNameWithFormat:@&quot;%@ -execute: %@&quot;, self, RACDescription(input)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法中这里你也能看到连续几次执行 -execute: 方法不能成功的原因：每次执行这个方法时，都会从另一个信号 immediateEnabled 中读取是否能执行当前命令的 BOOL 值，如果不可以执行的话，就直接返回 RACErrorSignal。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execute-on-RACCommand.png" alt=""></p><ul><li>execute: 方法是唯一一个为 addedExecutionSignalsSubject 生产信息的方法。</li></ul><p>在执行 signalBlock 返回一个 RACSignal 之后，会将当前信号包装成一个 RACMulticastConnection，然后调用 -sendNext: 方法发送到 addedExecutionSignalsSubject 上，执行 -connect 方法订阅原有的信号，最后返回。</p><h3 id="复杂的初始化"><a href="#复杂的初始化" class="headerlink" title="复杂的初始化"></a>复杂的初始化</h3><p>由于 RACCommand 在初始化方法中初始化了七个高阶信号，它的实现非常复杂，这里先介绍其中的 immediateExecuting 和 moreExecutionsAllowed 两个临时信号。</p><h4 id="immediateExecuting-表示当前有操作执行的信号"><a href="#immediateExecuting-表示当前有操作执行的信号" class="headerlink" title="immediateExecuting 表示当前有操作执行的信号"></a>immediateExecuting 表示当前有操作执行的信号</h4><p>我们看 immediateExecuting 信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *immediateExecuting = [[[[self.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        return [[[signal</span><br><span class="line">            catchTo:[RACSignal empty]]</span><br><span class="line">            then:^&#123;</span><br><span class="line">                return [RACSignal return:@-1];</span><br><span class="line">            &#125;]</span><br><span class="line">            startWith:@1];</span><br><span class="line">    &#125;]</span><br><span class="line">    scanWithStart:@0 reduce:^(NSNumber *running, NSNumber *next) &#123;</span><br><span class="line">        return @(running.integerValue + next.integerValue);</span><br><span class="line">    &#125;]</span><br><span class="line">    map:^(NSNumber *count) &#123;</span><br><span class="line">        return @(count.integerValue &gt; 0);</span><br><span class="line">    &#125;]</span><br><span class="line">    startWith:@NO];</span><br></pre></td></tr></table></figure><p>immediateExecuting 是一个用于表示当前是否有任务执行的信号，如果输入的 addedExecutionSignalsSubject 等价于以下的信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:[RACSignal error:[NSError errorWithDomain:@&quot;Error&quot; code:1 userInfo:nil]]];</span><br><span class="line">    [subscriber sendNext:[RACSignal return:@1]];</span><br><span class="line">    [subscriber sendNext:[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [RACScheduler.mainThreadScheduler afterDelay:1</span><br><span class="line">                                            schedule:^</span><br><span class="line">         &#123;</span><br><span class="line">             [subscriber sendCompleted];</span><br><span class="line">         &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;]];</span><br><span class="line">    [subscriber sendNext:[RACSignal return:@3]];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>那么最后生成的高阶信号 immediateExecuting 如下：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/immediateExecuting-Signal-in-RACCommand.png" alt=""></p><ol><li>-catchTo: 将所有的错误转换成 RACEmptySignal 信号</li><li>-flattenMap: 将每一个信号的开始和结束的时间点转换成 1 和 -1 两个信号</li><li>-scanWithStart:reduce: 从 0 开始累加原有的信号</li><li>-map: 将大于 1 的信号转换为 @yes</li><li>-startWith: 在信号序列最前面加入 @NO，表示在最开始时，没有任何动作在执行</li></ol><p>immediateExecuting 使用几个 RACSignal 的操作成功将原有的信号流转换成了表示是否有操作执行的信号流。</p><h4 id="moreExecutionsAllowed-表示是否允许更多操作执行的信号"><a href="#moreExecutionsAllowed-表示是否允许更多操作执行的信号" class="headerlink" title="moreExecutionsAllowed 表示是否允许更多操作执行的信号"></a>moreExecutionsAllowed 表示是否允许更多操作执行的信号</h4><p>相比于 immediateExecuting 信号的复杂，moreExecutionsAllowed 就简单多了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">    if:[self.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">    then:[RACSignal return:@YES]</span><br><span class="line">    else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure><p>因为文章中不准备介绍与并发执行有关的内容，所以这里的 then 语句永远不会执行，既然 RACCommand 不支持并行操作，那么这段代码就非常好理解了，当前 RACCommand 能否执行操作就是 immediateExecuting 取反：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/MoreExecutionAllowed-Signal.png" alt=""></p><p>到此这两个高阶操作就介绍完了。</p><h3 id="RACCommand-接口中的高阶信号"><a href="#RACCommand-接口中的高阶信号" class="headerlink" title="RACCommand 接口中的高阶信号"></a>RACCommand 接口中的高阶信号</h3><p>每一个 RACCommand 对象中都管理着多个信号，它在接口中暴露出四个重要信号：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCommand-Interface.png" alt=""></p><h4 id="executionSignals"><a href="#executionSignals" class="headerlink" title="executionSignals"></a>executionSignals</h4><p><code>executionSignals</code> 是 <code>RACCommand</code> 中最重要的信号；<br>从类型来看，它是一个包含信号的信号，在每次执行 <code>-execute:</code> 方法时，最终都会向 <code>executionSignals</code> 中传入一个最新的信号。</p><p>虽然它最重要，但是 <code>executionSignals</code> 是这个几个高阶信号中实现最简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_executionSignals = [[[self.addedExecutionSignalsSubject</span><br><span class="line">    map:^(RACSignal *signal) &#123;</span><br><span class="line">        return [signal catchTo:[RACSignal empty]];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    setNameWithFormat:@&quot;%@ -executionSignals&quot;, self];</span><br></pre></td></tr></table></figure><p>它只是将信号中的所有的错误 NSError 转换成了 RACEmptySignal 对象，并派发到主线程上。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Execution-Signals.png" alt=""></p><p>如果你只订阅了 executionSignals，那么其实你不会收到任何的错误，所有的错误都会以 -sendNext: 的形式被发送到 errors 信号中。</p><h4 id="executing"><a href="#executing" class="headerlink" title="executing"></a>executing</h4><p><code>executing</code> 是一个表示当前是否有任务执行的信号，这个信号使用了在上一节中介绍的临时变量作为数据源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_executing = [[[[[immediateExecuting</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    startWith:@NO]</span><br><span class="line">    distinctUntilChanged]</span><br><span class="line">    replayLast]</span><br><span class="line">    setNameWithFormat:@&quot;%@ -executing&quot;, self];</span><br></pre></td></tr></table></figure><p>这里对 immediateExecuting 的变换还是非常容易理解的：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Executing-Signal.png" alt=""></p><p>最后的 <code>replayLast</code> 方法将原有的信号变成了容量为 <code>1</code> 的 <code>RACReplaySubject</code> 对象，这样在每次有订阅者订阅 <code>executing</code> 信号时，都只会发送最新的状态，因为订阅者并不关心过去的 <code>executing</code> 的值。</p><h4 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h4><p><code>enabled</code> 信号流表示当前的命令是否可以再次被执行，也就是 <code>-execute:</code> 方法能否可以成功执行新的任务；该信号流依赖于另一个私有信号 <code>immediateEnabled：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *enabledSignal = [RACSignal return:@YES];</span><br><span class="line"></span><br><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">    combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">    and]</span><br><span class="line">    takeUntil:self.rac_willDeallocSignal]</span><br><span class="line">    replayLast];</span><br></pre></td></tr></table></figure><p>虽然这个信号的实现比较简单，不过它同时与三个信号有关，<code>enabledSignal</code>、<code>moreExecutionsAllowed</code> 以及 <code>rac_willDeallocSignal：</code></p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Immediate-Enabled-Signal.png" alt=""></p><p>虽然图中没有体现出方法 <code>-takeUntil:self.rac_willDeallocSignal</code> 的执行，不过你需要知道，这个信号在当前 <code>RACCommand</code> 执行 <code>dealloc</code> 之后就不会再发出任何消息了。</p><p>而 <code>enabled</code> 信号其实与 <code>immediateEnabled</code> 相差无几：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_enabled = [[[[[self.immediateEnabled</span><br><span class="line">    take:1]</span><br><span class="line">    concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">    distinctUntilChanged]</span><br><span class="line">    replayLast]</span><br><span class="line">    setNameWithFormat:@&quot;%@ -enabled&quot;, self];</span><br></pre></td></tr></table></figure><p>从名字你可以看出来，<code>immediateEnabled</code> 在每次原信号发送消息时都会重新计算，而 <code>enabled</code> 调用了 <code>-distinctUntilChanged</code> 方法，所以如果连续几次值相同就不会再次发送任何消息。</p><p>除了调用 <code>-distinctUntilChanged</code> 的区别之外，你可以看到 <code>enabled</code> 信号在最开始调用了 <code>-take:</code> 和 <code>-concat:</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[self.immediateEnabled</span><br><span class="line">take:1]</span><br><span class="line">concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]];</span><br></pre></td></tr></table></figure><p>虽然序列并没有任何的变化，但是在这种情况下，<code>enabled</code> 信号流中的第一个值会在订阅线程上到达，剩下的所有的值都会在主线程上派发；如果你知道，在一般情况下，我们都会使用 <code>enabled</code> 信号来控制 <code>UI</code> 的改变（例如 <code>UIButton</code>），相信你就会明白这么做的理由了。</p><h4 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h4><p>错误信号是 <code>RACCommand</code> 中比较简单的信号；为了保证 <code>RACCommand</code> 对此执行 <code>-execute:</code> 方法也可以继续运行，我们只能将所有的错误以其它的形式发送到 <code>errors</code> 信号中，防止向 <code>executionSignals</code> 发送错误信号后，<code>executionSignals</code> 信号就会中止的问题。</p><p>我们使用如下的方式创建 errors 信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACMulticastConnection *errorsConnection = [[[self.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        return [[signal</span><br><span class="line">            ignoreValues]</span><br><span class="line">            catch:^(NSError *error) &#123;</span><br><span class="line">                return [RACSignal return:error];</span><br><span class="line">            &#125;];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:@&quot;%@ -errors&quot;, self];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure><p>信号的创建过程是把所有的错误消息重新打包成 <code>RACErrorSignal</code> 并在主线程上进行派发：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Errors-Signals.png" alt=""></p><p>使用者只需要调用 <code>-subscribeNext:</code> 就可以从这个信号中获取所有执行过程中发生的错误。</p><h3 id="RACCommand-的使用"><a href="#RACCommand-的使用" class="headerlink" title="RACCommand 的使用"></a>RACCommand 的使用</h3><p><code>RACCommand</code> 非常适合封装网络请求，我们可以使用下面的代码封装一个网络请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) &#123;</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        NSURL *url = [NSURL URLWithString:@&quot;http://localhost:3000&quot;];</span><br><span class="line">        AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:url];</span><br><span class="line">        NSString *URLString = [NSString stringWithFormat:@&quot;/api/products/%@&quot;, input ?: @1];</span><br><span class="line">        NSURLSessionDataTask *task = [manager GET:URLString parameters:nil progress:nil</span><br><span class="line">             success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;</span><br><span class="line">                 [subscriber sendNext:responseObject];</span><br><span class="line">                 [subscriber sendCompleted];</span><br><span class="line">             &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">                 [subscriber sendError:error];</span><br><span class="line">             &#125;];</span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            [task cancel];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上面的 <code>RACCommand</code> 对象可以通过 <code>-execute:</code> 方法执行，同时，订阅 <code>executionSignals</code> 以及 <code>errors</code> 来获取网络请求的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[command.errors subscribeNext:^(NSError * _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line">[command execute:@1];</span><br></pre></td></tr></table></figure><p>向方法 <code>-execute:</code> 中传入了 <code>@1</code> 对象，从服务器中获取了 <code>id = 1</code> 的商品对象；当然，我们也可以传入不同的 <code>id</code> 来获取不同的模型，所有的网络请求以及 <code>JSON</code> 转换模型的逻辑都可以封装到这个 <code>RACCommand</code> 的 <code>block</code> 中，外界只是传入一个 <code>id</code>，最后就从 <code>executionSignals</code> 信号中获取了开箱即用的对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>RACCommand</code> 能够优雅地将包含副作用的操作和与副作用无关的操作分隔起来；整个 <code>RACCommand</code> 相当于一个黑箱，从 <code>-execute:</code> 方法中获得输入，最后以向信号发送消息的方式，向订阅者推送结果。</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACCommand-Side-Effect.png" alt=""></p><p>这种执行任务的方式就像是一个函数，根据输入的不同，有着不同的输出，非常适合与 <code>UI</code>、网络操作的相关的任务，这也是 <code>RACCommand</code> 的设计的优雅之处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RACCommand&quot;&gt;&lt;a href=&quot;#RACCommand&quot; class=&quot;headerlink&quot; title=&quot;RACCommand&quot;&gt;&lt;/a&gt;RACCommand&lt;/h2&gt;&lt;p&gt;RACCommand 在 ReactiveObjc 中是比较复杂的类，对于大
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>RACScheduler的用法</title>
    <link href="https://huangzhifei.github.io/2019/03/17/Objective-C/ReactiveObjc/RACScheduler%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://huangzhifei.github.io/2019/03/17/Objective-C/ReactiveObjc/RACScheduler的用法/</id>
    <published>2019-03-17T15:28:48.000Z</published>
    <updated>2020-01-05T02:55:03.370Z</updated>
    
    <content type="html"><![CDATA[<p><code>RACScheduler</code> 是一个线性执行队列，<code>ReactiveCocoa</code> 中的信号可以在 <code>RACScheduler</code> 上执行任务、发送结果；它的实现并不复杂，由多个简单的方法和类组成整个 <code>RACScheduler</code> 模块，是整个 <code>ReactiveCocoa</code> 中非常易于理解的部分。</p><h2 id="RACScheduler-简介"><a href="#RACScheduler-简介" class="headerlink" title="RACScheduler 简介"></a>RACScheduler 简介</h2><p><code>RACScheduler</code> 作为 <code>ReactiveCocoa</code> 中唯一的用于调度的模块，它包含很多个性化的子类：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACScheduler-Subclasses.png" alt=""></p><p><code>RACScheduler</code> 类的内部只有一个用于追踪标记和 <code>debug</code> 的属性 <code>name</code>，头文件和实现文件中的其它内容都是各种各样的方法；我们可以把其中的方法分为两类：</p><p>一类是用于初始化 <code>RACScheduler</code> 实例的初始化方法：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACScheduler-Initializers.png" alt=""></p><p>另一类就是用于调度、执行任务的 +schedule: 等方法：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACScheduler-Schedule.png" alt=""></p><p>在图中省略了一些参数，以及一些调用其他方法的调度方法或者初始化方法。</p><p>在 <code>RACScheduler</code> 中，大部分的调度方法都是需要子类覆写，它本身只提供少数的功能，比如递归 <code>block</code> 的执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">[self scheduleRecursiveBlock:[recursiveBlock copy] addingToDisposable:disposable];</span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会递归的执行传入的 <code>recursiveBlock</code>，使用的方式非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[scheduler scheduleRecursiveBlock:^(void (^reschedule)(void)) &#123;</span><br><span class="line">    if (needTerminated) return;</span><br><span class="line">    </span><br><span class="line">    // do something</span><br><span class="line"></span><br><span class="line">    reschedule();</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>如果需要递归就执行方法中的 <code>reschedule()</code>，就会再次执行当前的 <code>block</code>；<code>-scheduleRecursiveBlock:</code> 中调用的 <code>-scheduleRecursiveBlock:addingToDisposable:</code> 实现比较复杂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock addingToDisposable:(RACCompoundDisposable *)disposable &#123;</span><br><span class="line">    ...</span><br><span class="line">    RACDisposable *schedulingDisposable = [self schedule:^&#123;</span><br><span class="line">        void (^reallyReschedule)(void) = ^&#123;</span><br><span class="line">            [self scheduleRecursiveBlock:recursiveBlock addingToDisposable:disposable];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        recursiveBlock(^&#123;</span><br><span class="line">            reallyReschedule();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>方法使用了 NSLock 保证在并发情况下并不会出现任何问题，不过在这里展示的代码中，我们将它省略了，一并省略的还有 RACDisposable 相关的代码，以保证整个方法逻辑的清晰。</code></p><p>在每次执行 <code>recursiveBlock</code> 时，都会传入一个 <code>reallyReschedule</code> 用于递归执行传入的 <code>block</code>。</p><p>其他的方法包括 <code>+schedule:</code>、<code>+after:schedule:</code> 以及 <code>after:repeatingEvery:withLeeway:schedule:</code> 方法都需要子类覆写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)schedule:(void (^)(void))block;</span><br><span class="line">- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block;</span><br><span class="line">- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block &#123;</span><br><span class="line">NSCAssert(NO, @&quot;%@ must be implemented by subclasses.&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而接下来我们就按照初始化方法的顺序依次介绍 RACScheduler 的子类了。</p><h3 id="RACImmediateScheduler"><a href="#RACImmediateScheduler" class="headerlink" title="RACImmediateScheduler"></a>RACImmediateScheduler</h3><p><code>RACImmediateScheduler</code> 是一个会立即执行传入的代码块的调度器，我们可以使用 <code>RACScheduler</code> 的类方法 <code>+immediateScheduler</code> 返回一个它的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACScheduler *)immediateScheduler &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static RACScheduler *immediateScheduler;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">immediateScheduler = [[RACImmediateScheduler alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line">return immediateScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>RACImmediateScheduler</code> 是一个私有类，全局只能通过该方法返回它的实例，所以整个程序的运行周期内，我们通过『合法』手段只能获得唯一一个单例。</p><p>作为 <code>RACScheduler</code> 的子类，它必须对父类的调度方法进行覆写，不过因为本身的职能原因，<code>RACImmediateScheduler</code> 对于父类的覆写还是非常简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;</span><br><span class="line">block();</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block &#123;</span><br><span class="line">[NSThread sleepUntilDate:date];</span><br><span class="line">block();</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block &#123;</span><br><span class="line">NSCAssert(NO, @&quot;+[RACScheduler immediateScheduler] does not support %@.&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>+schedule</code> 方法会立刻执行传入的 <code>block</code>；</li><li><code>+after:schedule:</code> 方法会将当前线程休眠到指定时间后执行 <code>block</code>；</li><li>而对于 <code>+after:repeatingEvery:withLeeway:schedule:</code> 方法就干脆不支持。</li></ol><p>这确实非常符合 <code>RACImmediateScheduler</code> 类的名字以及功能，虽然没有要求对递归执行 <code>block</code> 的方法进行覆写，不过它依然做了这件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock &#123;</span><br><span class="line">for (__block NSUInteger remaining = 1; remaining &gt; 0; remaining--) &#123;</span><br><span class="line">recursiveBlock(^&#123;</span><br><span class="line">remaining++;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的过程非常简洁，甚至没有什么值得解释的地方了。</p><h3 id="RACTargetQueueScheduler"><a href="#RACTargetQueueScheduler" class="headerlink" title="RACTargetQueueScheduler"></a>RACTargetQueueScheduler</h3><p><code>RACTargetQueueScheduler</code> 继承自 <code>RACQueueScheduler</code>，但是由于后者是抽象类，我们并不会直接使用它，它只是为前者提供必要的方法支持，将一部分逻辑抽离出来：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACTargetQueueScheduler.png" alt=""></p><p>这里我们先简单看一下 <code>RACTargetQueueScheduler</code> 的实现，整个 <code>RACTargetQueueScheduler</code> 类中只有一个初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)name targetQueue:(dispatch_queue_t)targetQueue &#123;</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(name.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_set_target_queue(queue, targetQueue);</span><br><span class="line">return [super initWithName:name queue:queue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法 <code>-initWithName:targetQueue:</code> 使用 <code>dispatch_queue_create</code> 创建了一个串行队列，然后通过 <code>dispatch_set_target_queue</code> 根据传入的 <code>targetQueue</code> 设置队列的优先级，最后调用父类的指定构造器完成整个初始化过程。</p><p><code>RACTargetQueueScheduler</code> 在使用时，将待执行的任务加入一个私有的串行队列中，其优先级与传入的 <code>targetQueue</code> 完全相同；不过提到 <code>RACTargetQueueScheduler</code> 中队列的优先级，对 <code>GCD</code> 稍有了解的人应该都知道在 <code>GCD</code> 中有着四种不同优先级的全局并行队列，而在 <code>RACScheduler</code> 中也有一一对应的枚举类型：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACScheduler-Priority.png" alt=""></p><p>在使用 <code>+schedulerWithPriority:</code> 方法创建 <code>RACTargetQueueScheduler</code> 时，就需要传入上面的优先级，方法会通过 <code>GCD</code> 的内置方法 <code>dispatch_get_global_queue</code> 获取全局的并行队列，最终返回一个新的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority name:(NSString *)name &#123;</span><br><span class="line">return [[RACTargetQueueScheduler alloc] initWithName:name targetQueue:dispatch_get_global_queue(priority, 0)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>RACScheduler</code> 接口中另一个获得主线程调度器的方法 <code>+mainThreadScheduler</code>，其实现也是返回一个 <code>RACTargetQueueScheduler</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACScheduler *)mainThreadScheduler &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static RACScheduler *mainThreadScheduler;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">mainThreadScheduler = [[RACTargetQueueScheduler alloc] initWithName:@&quot;org.reactivecocoa.ReactiveObjC.RACScheduler.mainThreadScheduler&quot; targetQueue:dispatch_get_main_queue()];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return mainThreadScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与前者不同的是，后者通过单例模式每次调用时返回一个相同的主线程队列。</p><h3 id="抽象类-RACQueueScheduler"><a href="#抽象类-RACQueueScheduler" class="headerlink" title="抽象类 RACQueueScheduler"></a>抽象类 RACQueueScheduler</h3><p>在我们对 <code>RACTargetQueueScheduler</code> 有一定了解之后，再看它的抽象类就非常简单了；<code>RACImmediateScheduler</code> 会立即执行传入的任务，而 <code>RACQueueScheduler</code> 其实就是对 <code>GCD</code> 的封装，相信各位读者从它的子类的实现就可以看出来。</p><p><code>RACQueueScheduler</code> 对三个需要覆写的方法都进行了重写，其实现完全基于 <code>GCD</code>，以 <code>-schedule:</code> 方法为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;</span><br><span class="line">RACDisposable *disposable = [[RACDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(self.queue, ^&#123;</span><br><span class="line">if (disposable.disposed) return;</span><br><span class="line">[self performAsCurrentScheduler:block];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>dispatch_async</code> 方法直接将需要执行的任务异步派发到它所持有的队列上；而 <code>-after:schedule:</code> 方法的实现相信各位读者也能猜到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block &#123;</span><br><span class="line">RACDisposable *disposable = [[RACDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_after([self.class wallTimeWithDate:date], self.queue, ^&#123;</span><br><span class="line">if (disposable.disposed) return;</span><br><span class="line">[self performAsCurrentScheduler:block];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哪怕不使用 <code>RACScheduler</code>，我们也能够想到利用 <code>dispatch_after</code> 完成一些需要延迟执行的任务，最后的 <code>+after:repeatingEvery:withLeeway:schedule:</code> 方法的实现就稍微复杂一些了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block &#123;</span><br><span class="line">uint64_t intervalInNanoSecs = (uint64_t)(interval * NSEC_PER_SEC);</span><br><span class="line">uint64_t leewayInNanoSecs = (uint64_t)(leeway * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.queue);</span><br><span class="line">dispatch_source_set_timer(timer, [self.class wallTimeWithDate:date], intervalInNanoSecs, leewayInNanoSecs);</span><br><span class="line">dispatch_source_set_event_handler(timer, block);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line">return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">dispatch_source_cancel(timer);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法使用 <code>dispatch_source_t</code> 以及定时器，完成了每隔一段时间需要执行任务的需求。</p><h3 id="RACSubscriptionScheduler"><a href="#RACSubscriptionScheduler" class="headerlink" title="RACSubscriptionScheduler"></a>RACSubscriptionScheduler</h3><p>最后的 <code>RACSubscriptionScheduler</code> 是 <code>ReactiveCocoa</code> 中一个比较特殊的调度器，所有 <code>ReactiveCocoa</code> 中的订阅事件都会在 <code>RACSubscriptionScheduler</code> 调度器上进行；而它是通过封装两个调度器实现的：</p><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/RACSubscriptionScheduler.png" alt=""></p><p><code>backgroundScheduler 是一个优先级为 RACSchedulerPriorityDefault 的串行队列。</code></p><p><code>RACSubscriptionScheduler</code> 本身不提供任何的调度功能，它会根据当前状态选择持有的两个调度器中的一个执行任务；首先判断当前线程是否存在 <code>currentScheduler</code>，如果不存在的话才会在 <code>backgroundScheduler</code> 执行任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;</span><br><span class="line">if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];</span><br><span class="line">block();</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block &#123;</span><br><span class="line">RACScheduler *scheduler = RACScheduler.currentScheduler ?: self.backgroundScheduler;</span><br><span class="line">return [scheduler after:date schedule:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block &#123;</span><br><span class="line">RACScheduler *scheduler = RACScheduler.currentScheduler ?: self.backgroundScheduler;</span><br><span class="line">return [scheduler after:date repeatingEvery:interval withLeeway:leeway schedule:block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RACSubscriptionScheduler</code> 作为一个私有类，我们并不能直接在 <code>ReactiveCocoa</code> 外部使用它，需要通过私有方法 <code>+subscriptionScheduler</code> 获取这个调度器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (RACScheduler *)subscriptionScheduler &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static RACScheduler *subscriptionScheduler;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return subscriptionScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>RACScheduler</code> 在某些方面与 <code>GCD</code> 中的队列十分相似，与 <code>GCD</code> 中的队列不同的有两点，第一，它可以通过 <code>RACDisposable</code> 对执行中的任务进行取消，第二是 <code>RACScheduler</code> 中任务的执行都是线性的；与此同时 <code>RACScheduler</code> 也与 <code>NSOperationQueue</code> 非常类似，但是它并不支持对调度的任务进行重排序以及实现任务与任务之间的依赖关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;RACScheduler&lt;/code&gt; 是一个线性执行队列，&lt;code&gt;ReactiveCocoa&lt;/code&gt; 中的信号可以在 &lt;code&gt;RACScheduler&lt;/code&gt; 上执行任务、发送结果；它的实现并不复杂，由多个简单的方法和类组成整个 &lt;code
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>iOS navigationItem titleView 居中</title>
    <link href="https://huangzhifei.github.io/2019/03/11/Objective-C/2019/iOS%20navigationItem%20titleView%20%E5%B1%85%E4%B8%AD/"/>
    <id>https://huangzhifei.github.io/2019/03/11/Objective-C/2019/iOS navigationItem titleView 居中/</id>
    <published>2019-03-11T07:45:50.000Z</published>
    <updated>2020-01-05T02:55:03.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-11-以前"><a href="#iOS-11-以前" class="headerlink" title="iOS 11 以前"></a>iOS 11 以前</h2><p>在 iOS 11 以前要让自定义标题居中，那就是蛋疼的一地了。</p><p>1、首先要知道 leftBarButtonItems 与 rightBarButtonItems 的个数，因为他会影响标题的位置。</p><p>2、要算出标题的实际大小（含有富文本和多行）。</p><p>3、在合适的机会以屏幕为中心计算标题相对屏幕中心的坐标。</p><p>我们为了不耦合控制器，我们把细节封装到内部，我们就假设自己不知道 leftBarButtonItems 与 rightBarButtonItems 的个数，都假设为 1 个（大小大约为 66）。</p><p>然后我们使用 sizeThatFits 去计算出实际的大小，这里有富文本和多行使用 sizeToFit 计算不准确。</p><p>最后我们在 layoutSubviews 里面去改变其 frame，让其居中。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 暴露 API，外部调用，用来设置标题的</span><br><span class="line"></span><br><span class="line">if (@available(iOS 11, *)) &#123;</span><br><span class="line">    // 走 AutoLayout 了</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    self.titleSize = [self.nameLabel sizeThatFits:CGSizeMake([UIScreen mainScreen].bounds.size.width - 66 * 2, 44)];</span><br><span class="line">    // 标记为需要 layout (iOS 11以下需要标记)</span><br><span class="line">    [self setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 布局</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    if (!CGSizeEqualToSize(self.titleSize, CGSizeZero)) &#123;</span><br><span class="line">        if (@available(iOS 11, *)) &#123;</span><br><span class="line">            // iOS 11 及以上系统走的是自动布局，设置这里没用</span><br><span class="line">            NSLog(@&quot;do nothing&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // x 轴相对屏幕中心的偏移</span><br><span class="line">            CGFloat title_x = ([UIScreen mainScreen].bounds.size.width * 0.5 - self.origin.x - self.titleSize.width * 0.5) + 0.5;</span><br><span class="line">            // y 轴相对屏幕中心的偏移</span><br><span class="line">            CGFloat title_y = (44 - self.titleSize.height) * 0.5;</span><br><span class="line">            [self.nameLabel setFrame:CGRectMake(title_x, title_y, self.titleSize.width + 1, self.titleSize.height + 1)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS-11及以后"><a href="#iOS-11及以后" class="headerlink" title="iOS 11及以后"></a>iOS 11及以后</h2><p>在 iOS 11 及以后，系统改变了 navigationItem 的 titleView 的位置及布局方式，他不在 UINavigationBar 的视图层级了，而是加到了 UINavigationBarContentView 上面了。他使用了 AutoLayout，这样一来反而简单了，自定义一个 UIView 后，直接赋值，里面做好 autoLayout，就搞定了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (@available(iOS 11, *)) &#123;</span><br><span class="line">        [self.nameLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.edges.equalTo(self);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>nameLabel （nameLabel 是可以设置多行或富文本的）作为 customTitleView 的载体，外面调用地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 添加自定义titleview</span><br><span class="line">self.navigationItem.titleView = self.navTitleView;</span><br></pre></td></tr></table></figure><p>或者碰到宽度没有正常拉伸的，使用下面方式即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (CGSize)intrinsicContentSize &#123;</span><br><span class="line">return UILayoutFittingExpandedSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS-11-以前&quot;&gt;&lt;a href=&quot;#iOS-11-以前&quot; class=&quot;headerlink&quot; title=&quot;iOS 11 以前&quot;&gt;&lt;/a&gt;iOS 11 以前&lt;/h2&gt;&lt;p&gt;在 iOS 11 以前要让自定义标题居中，那就是蛋疼的一地了。&lt;/p&gt;
&lt;p&gt;1、首
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>RAC 一些高级用法总结</title>
    <link href="https://huangzhifei.github.io/2019/03/08/Objective-C/ReactiveObjc/RAC%20%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://huangzhifei.github.io/2019/03/08/Objective-C/ReactiveObjc/RAC 一些高级用法总结/</id>
    <published>2019-03-08T05:53:07.000Z</published>
    <updated>2020-01-05T02:55:03.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bind-绑定-包装"><a href="#bind-绑定-包装" class="headerlink" title="bind 绑定/包装"></a>bind 绑定/包装</h3><p>bind 主要作用属于包装，将信号返回的值包装成一个新的值，然后在通过信号返回给订阅者。</p><ol><li>传入一个返回值 RACSignalBindBlock 的 block</li><li>描述一个 RACSignalBindBlock 类型的 bindBlock 作为 block 的返回值</li><li>描述一个返回结果的信号，作为 bindBlock 的返回值，注意在 bindBlock 中做信号结果的处理</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.textField.rac_textSignal bind:^RACSignalBindBlock _Nonnull &#123;</span><br><span class="line">    return ^RACSignal *(id value, BOOL *stop) &#123;</span><br><span class="line">        // 做好处理，通过信号返回出去.</span><br><span class="line">        return [RACSignal return:[NSString stringWithFormat:@&quot;hello: %@&quot;, value]];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;] subscribeNext:^(id _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;bind content: %@&quot;, x); // hello: xxxxx</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="distinctUntilChanged-对比上一次信号内容"><a href="#distinctUntilChanged-对比上一次信号内容" class="headerlink" title="distinctUntilChanged 对比上一次信号内容"></a>distinctUntilChanged 对比上一次信号内容</h3><p>实现是用 bind 来完成的，每次变换中都记录一下原信号上一次发送过来的值，并与这一次进行比较，如果是相同的值，就“吞掉”，返回 empty 信号，只有和原信号上一次发送的值不同才会变换成新信号把这个值发送出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">[[signal distinctUntilChanged] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;distinctUntilChanged : %@&quot;, x); // will only print &quot;eric&quot;, &quot;eric hzf&quot;, &quot;eric&quot;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 发送一次信号，内容为 eric</span><br><span class="line">[signal sendNext:@&quot;eric&quot;];</span><br><span class="line"></span><br><span class="line">// 发送二次信号，内容依然为 eric，但是使用 distinctUntilChanged 后不会在接收与上一次重复的内容</span><br><span class="line">[signal sendNext:@&quot;eric&quot;];</span><br><span class="line"></span><br><span class="line">// 发送三次信号，内容为 eric hzf</span><br><span class="line">[signal sendNext:@&quot;eric hzf&quot;];</span><br></pre></td></tr></table></figure><h3 id="flattenMap-amp-map-映射"><a href="#flattenMap-amp-map-映射" class="headerlink" title="flattenMap &amp; map 映射"></a>flattenMap &amp; map 映射</h3><p>flattenMap 和 map 都是用于把源信号内容映射成新的内容</p><h5 id="flattenMap-的底层实现是通过-bind-实现的"><a href="#flattenMap-的底层实现是通过-bind-实现的" class="headerlink" title="flattenMap 的底层实现是通过 bind 实现的"></a>flattenMap 的底层实现是通过 bind 实现的</h5><h5 id="map-的底层实现是通过-flattenMap-实现的"><a href="#map-的底层实现是通过-flattenMap-实现的" class="headerlink" title="map 的底层实现是通过 flattenMap 实现的"></a>map 的底层实现是通过 flattenMap 实现的</h5><h4 id="flattenMap-使用步骤："><a href="#flattenMap-使用步骤：" class="headerlink" title="flattenMap 使用步骤："></a>flattenMap 使用步骤：</h4><ol><li>传入一个block，block 类型是返回值 RACStream，参数 value;</li><li>参数 value 就是源信号的内容，拿到源信号的内容做处理；</li><li>包装成 RACReturnSignal 信号，返回出去。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[_textField.rac_textSignal flattenMap:^__kindof RACSignal * _Nullable(NSString * _Nullable value) &#123;</span><br><span class="line">    return  [RACSignal return:[NSString stringWithFormat:@&quot;hello %@&quot;, value]];</span><br><span class="line">&#125;] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x); // hello &quot;x&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="map-使用步骤："><a href="#map-使用步骤：" class="headerlink" title="map 使用步骤："></a>map 使用步骤：</h4><ol><li>传入一个 block，类型是返回对象，参数是 value；</li><li>value 就是源信号的内容，直接拿到源信号的内容做处理；</li><li>把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[_textField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123;</span><br><span class="line">    // 当源信号发出，就会调用这个block，修改源信号的内容</span><br><span class="line">    // 返回值：就是处理完源信号的内容。</span><br><span class="line">    return [NSString stringWithFormat:@&quot;hello:%@&quot;,value];</span><br><span class="line">&#125;] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x); // hello: &quot;x&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="flattenMap-amp-map-区别"><a href="#flattenMap-amp-map-区别" class="headerlink" title="flattenMap &amp; map 区别"></a>flattenMap &amp; map 区别</h4><ol><li>flattenMap 中的 block 返回的是信号</li><li>map 中的 block 返回的是对象</li><li>开发中，如果信号发出的值不是信号，映射一般使用 map</li><li>开发中，如果信号发出的值是信号，映射一般使用 flattenMap</li></ol><h3 id="concat-合并，有顺序的处理多个信号"><a href="#concat-合并，有顺序的处理多个信号" class="headerlink" title="concat 合并，有顺序的处理多个信号"></a>concat 合并，有顺序的处理多个信号</h3><p>按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建两个信号 signalA 和 signalB</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;signalA sendNext&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;A&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;AA&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;signalB sendNext&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;B&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活</span><br><span class="line">[[signalA concat:signalB] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;contact :%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>第一个信号必须发送完成，第二个信号才会被激活。</p><h3 id="then-下一个"><a href="#then-下一个" class="headerlink" title="then 下一个"></a>then 下一个</h3><p>用于连接两个信号，当第一个信号完成后，才会连接 then 返回的信号</p><p>底层实现</p><ol><li>使用 concat 连接 then 返回的信号</li><li>先过滤掉之前的信号发出的值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;test1&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] then:^RACSignal * _Nonnull&#123;</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;test2&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // 只能接收到第二个信号的值，也就是then返回信号的值</span><br><span class="line">    NSLog(@&quot;then content: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>会过滤掉第一个 “test1”，只接收第二个信号发送过来的值。</p><h3 id="merge-合并，合成一个信号"><a href="#merge-合并，合成一个信号" class="headerlink" title="merge 合并，合成一个信号"></a>merge 合并，合成一个信号</h3><p>把多个信号合并为一个信号，任何一个信号有新值的时候就会调用，没有先后顺序，依赖关系（和 concat 的区别）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;merge signal 1&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    RACSignal *signalB = [RACSignal createSignal:^RACDisposable *_Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;merge signal 2&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 合并信号,任何一个信号发送数据，都能监听到.</span><br><span class="line">    RACSignal *mergeSignal = [signalA merge:signalB];</span><br><span class="line">    [mergeSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;merge content: %@&quot;, x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p><strong>注意：只要有一个信号被发出就会被监听</strong></p><h3 id="combineLatest-结合"><a href="#combineLatest-结合" class="headerlink" title="combineLatest 结合"></a>combineLatest 结合</h3><p>将多个信号合并起来，并且拿到各个信号的最新的值，必须每个合并的 signal 至少都有一次 sendNext，才会触发合并的信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;combineLatest signalA&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;combineLatest signalB&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 把两个信号组合成一个信号,跟zip一样，没什么区别</span><br><span class="line">RACSignal *combineSignal = [signalA combineLatestWith:signalB];</span><br><span class="line"></span><br><span class="line">[combineSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;combineLatest content: %@&quot;,x); // (combineLatest signalA, combineLatest signalB)</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="reduce-聚合"><a href="#reduce-聚合" class="headerlink" title="reduce 聚合"></a>reduce 聚合</h3><p>用于信号发出的内容是元组，把信号发出元组的值聚合成一个值，一般都是先组合在聚合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;reduce signalA&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;reduce signalB&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// reduceblock的返回值：聚合信号之后的内容。</span><br><span class="line">RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2)&#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[reduceSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;reduce content: %@&quot;,x); // (reduce signalA, reduce signalB)</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter 过滤"></a>filter 过滤</h3><p>过滤信号，获取满足条件的信号 </p><p>获取到位数大于 6 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[self.textField.rac_textSignal filter:^BOOL(NSString *value) &#123;</span><br><span class="line">    return value.length &gt; 6;</span><br><span class="line">&#125;] subscribeNext:^(NSString * _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;filter content: %@&quot;,x); // x 值位数大于6</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="ignore-忽略"><a href="#ignore-忽略" class="headerlink" title="ignore 忽略"></a>ignore 忽略</h3><p>忽略掉指定的值</p><p>忽略掉值为 “999” 的信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[self.textField.rac_textSignal ignore:@&quot;999&quot;] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;ignore content: %@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="interval-定时"><a href="#interval-定时" class="headerlink" title="interval 定时"></a>interval 定时</h3><p>每隔一段时间发出信号</p><p>类似于 NSTimer</p><p>每隔 1 秒发送一次信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 这个就是RAC中的GCD</span><br><span class="line">self.disposable = [[RACSignal interval:1.0 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDate *_Nullable x) &#123;</span><br><span class="line">    self.time--;</span><br><span class="line">    NSString *title = self.time &gt; 0 ? [NSString stringWithFormat:@&quot;请等待 %ld 秒后重试&quot;, self.time] : @&quot;发送验证码&quot;;</span><br><span class="line">    [self.countDownBtn setTitle:title forState:UIControlStateNormal];</span><br><span class="line">    self.countDownBtn.enabled = (self.time == 0) ? YES : NO;</span><br><span class="line">    if (self.time == 0) &#123;</span><br><span class="line">        // 取消这个订阅</span><br><span class="line">        [self.disposable dispose];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="delay-延迟"><a href="#delay-延迟" class="headerlink" title="delay 延迟"></a>delay 延迟</h3><p>延迟执行，类似于 GCD 的 after。</p><p>下面例子主要是延迟发送 next</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;delay signalA&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] delay:2] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>延迟 2 秒后收到 信号 @”delay signalA”</p><h3 id="take-取信号"><a href="#take-取信号" class="headerlink" title="take 取信号"></a>take 取信号</h3><p>从开始一共取 N 次的信号发送（0 - (N-1))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 取前 N 个</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;signal 1&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal 2&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal 3&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] take:2] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;take content: %@&quot;, x); // only 1 and 2 will be print</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="skip-跳过"><a href="#skip-跳过" class="headerlink" title="skip 跳过"></a>skip 跳过</h3><p>从开始一共跳过 N 次的信号发送，只接受之后的信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 跳过前 N 个</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;signal 1&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal 2&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal 3&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] skip:2] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;skip : %@&quot;, x); // only 3 will be print</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="takeUntil-获取信号当某个信号执行完成就停止订阅"><a href="#takeUntil-获取信号当某个信号执行完成就停止订阅" class="headerlink" title="takeUntil 获取信号当某个信号执行完成就停止订阅"></a>takeUntil 获取信号当某个信号执行完成就停止订阅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// RAC 这个消息是 2 秒后完成, 所以 signal1 signal2 这两个消息是可以发送到 而 3 秒后的 signal3 signal4 就不会发送.</span><br><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *_Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;signal1&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal2&quot;];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [subscriber sendNext:@&quot;signal3&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;signal4&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;);</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] takeUntil:[RACSignal createSignal:^RACDisposable *_Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">       dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           [subscriber sendNext:@&quot;RAC&quot;];</span><br><span class="line">           [subscriber sendCompleted];</span><br><span class="line">       &#125;);</span><br><span class="line">       return nil;</span><br><span class="line">   &#125;]];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;takeUntil: %@&quot;, x); // only signal1 &amp; signal2 will be print</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="takeLast-获取最后-N-次的信号"><a href="#takeLast-获取最后-N-次的信号" class="headerlink" title="takeLast 获取最后 N 次的信号"></a>takeLast 获取最后 N 次的信号</h3><p>前提条件：订阅者必须调用完成，因为只有完成，才知道总共有多少个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;signal1&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal2&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal3&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;signal4&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    // 上面调用 sendCompleted 之后，会直接进入下面的订阅回调，打印最后 3 条信号，然后在打印下面的 &quot;send completed&quot;</span><br><span class="line">    NSLog(@&quot;send completed&quot;);</span><br><span class="line">    return nil;</span><br><span class="line"></span><br><span class="line">&#125;] takeLast:3];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;testTakeLast : %@&quot;,x); // 会打印最后 3 条，并且所有的信号都已经发送完成了。</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest"></a>switchToLatest</h3><p>获取信号中信号最近发出信号，订阅最近发出的信号。</p><p>注意：switchToLatest 使用的对象是信号中的信号（signalOfsignals)，即 sendNext 的参数也是信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line">RACSubject *signalB = [RACSubject subject];</span><br><span class="line">// 获取信号中信号最近发出信号，订阅最近发出的信号。</span><br><span class="line">// 注意switchToLatest：只能用于信号中的信号</span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;switchToLatest: %@&quot;, x); // will only print signalB</span><br><span class="line">&#125;];</span><br><span class="line">[signalOfSignals sendNext:signalA];</span><br><span class="line">[signalOfSignals sendNext:signalB];</span><br><span class="line">[signalA sendNext:@&quot;signalA&quot;];</span><br><span class="line">[signalB sendNext:@&quot;signalB&quot;];</span><br></pre></td></tr></table></figure><h3 id="doNext"><a href="#doNext" class="headerlink" title="doNext"></a>doNext</h3><p>执行 next 之前，会先执行这个 block</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;testDoNextAndDoCompleted start sendNext&quot;);</span><br><span class="line">    [subscriber sendNext:@&quot;hello do next&quot;];</span><br><span class="line">    NSLog(@&quot;testDoNextAndDoCompleted end sendNext&quot;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;testDoNextAndDoCompleted start sendCompleted&quot;);</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    NSLog(@&quot;testDoNextAndDoCompleted end sendCompleted&quot;);</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;] doNext:^(id  _Nullable x) &#123;</span><br><span class="line">    // 在执行 [subscriber sendNext:@&quot;hello do next&quot;]; 之前会先执行 doNext：</span><br><span class="line">    NSLog(@&quot;test do next&quot;);</span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line">    // 在执行 [subscriber sendCompleted]; 之前会先执行 doCompleted：</span><br><span class="line">    NSLog(@&quot;test do completed&quot;);</span><br><span class="line">&#125;] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;testDoNextAndDoCompleted: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 最终打印顺序：</span><br><span class="line"> </span><br><span class="line"> testDoNextAndDoCompleted start sendNext</span><br><span class="line"> test do next</span><br><span class="line"> testDoNextAndDoCompleted: hello do next</span><br><span class="line"> testDoNextAndDoCompleted end sendNext</span><br><span class="line"> testDoNextAndDoCompleted start sendCompleted</span><br><span class="line"> test do completed</span><br><span class="line"> testDoNextAndDoCompleted end sendCompleted</span><br><span class="line"></span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><h3 id="doCompleted"><a href="#doCompleted" class="headerlink" title="doCompleted"></a>doCompleted</h3><p>执行 sendCompleted 之前，会先执行这个Block。</p><p>详细例子见上面 doNext</p><h3 id="timeout-超时"><a href="#timeout-超时" class="headerlink" title="timeout 超时"></a>timeout 超时</h3><p>如果一个信号在指定时间内没有发送信号，就会超时，可以让一个信号在一定的时间后，自动报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    </span><br><span class="line">    //无任何操作 等超时</span><br><span class="line">    </span><br><span class="line">//        [subscriber sendNext:@&quot;signal A&quot;];</span><br><span class="line">//        NSError *error = [[NSError alloc]initWithDomain:@&quot;unknwn domain&quot; code:600 userInfo:@&#123;@&quot;error&quot;:@&quot;超时&quot;&#125;];</span><br><span class="line">//        [subscriber sendError:error];</span><br><span class="line">//        [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] timeout:3.0 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;timeout :%@&quot;, x); // 超时后不会进入到这里</span><br><span class="line">&#125; error:^(NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;timeout 超时: %@&quot;, error); // 3 秒超时后，会打印超时错误</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="retry-重试-或-retry-count"><a href="#retry-重试-或-retry-count" class="headerlink" title="retry 重试 或 retry:count"></a>retry 重试 或 retry:count</h3><p>重试，只要失败，就会重新执行创建信号中的 block，一直重试，直到成功。<br>如果后面指定次数，就会在相应的次数之后结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 重试，不执行 error block，一直到执行 sendNext 成功才结束</span><br><span class="line">__block NSInteger count = 1;</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable *_Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (count == 5) &#123;</span><br><span class="line">            [subscriber sendNext:@&quot;retry 执行 sendNext 成功&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 注意：这里一定要发送一个错误信号，不然就不会继续往下面走，也就永远不会达到错误重试的次数和效果</span><br><span class="line">            // 但是这个 error 是不会被下面的 error：订阅到的，也就是说不会触发下面那个 error：的监听</span><br><span class="line">            [subscriber sendError:[NSError errorWithDomain:@&quot;unknown domain&quot;</span><br><span class="line">                                                      code:500</span><br><span class="line">                                                  userInfo:@&#123;</span><br><span class="line">                                                      @&quot;msg&quot; : [NSString stringWithFormat:@&quot;次数：%ld&quot;, count]</span><br><span class="line">                                                  &#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] retry:6] subscribeNext:^(id _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;retry: %@&quot;, x);</span><br><span class="line">&#125; error:^(NSError *_Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;retry error: %@&quot;, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>注意上面代码中的注释，必须要发送一个 error 信号的，并且要知道他是错误重试，如果不发生错误就不会重试的。</p><h3 id="replay-反复播放（不是重新触发执行）"><a href="#replay-反复播放（不是重新触发执行）" class="headerlink" title="replay 反复播放（不是重新触发执行）"></a>replay 反复播放（不是重新触发执行）</h3><p>多个订阅者，只执行一遍副作用，如果没有 replay 就要重复执行副作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__block NSInteger count = 1; // 副作用</span><br><span class="line">    RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:[NSString stringWithFormat:@&quot;signal A with count = %ld&quot;, count]];</span><br><span class="line">        ++ count;</span><br><span class="line">        [subscriber sendNext:[NSString stringWithFormat:@&quot;signal B with count = %ld&quot;, count]];</span><br><span class="line">        ++count;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;] replay];</span><br><span class="line">    </span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;test replay 订阅1: %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;test replay 订阅2: %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 使用 replay 打印输出：</span><br><span class="line">    /*</span><br><span class="line">     test replay 订阅1: signal A with count = 1</span><br><span class="line">     test replay 订阅1: signal B with count = 2</span><br><span class="line">     test replay 订阅2: signal A with count = 1</span><br><span class="line">     test replay 订阅2: signal B with count = 2</span><br><span class="line">     **/</span><br><span class="line">    </span><br><span class="line">    // 不使用 replay 打印输出：</span><br><span class="line">    /*</span><br><span class="line">     test replay 订阅1: signal A with count = 1</span><br><span class="line">     test replay 订阅1: signal B with count = 2</span><br><span class="line">     test replay 订阅2: signal A with count = 3</span><br><span class="line">     test replay 订阅2: signal B with count = 4</span><br><span class="line">     **/</span><br></pre></td></tr></table></figure><p>从上面的打印可以看出来：</p><ol><li>使用 replay 之后，就像是一个镜像一样了，之后的订阅都是在重复播放之前的镜像，所以外面的副作用 count 的值不会在继续增长。</li><li>不使用 replay 的话，那么下面的每一次的订阅都会重新触发一次发送信号，副作用 count 的值就会持续增长。</li></ol><h3 id="repeat-无限循环的重复执行"><a href="#repeat-无限循环的重复执行" class="headerlink" title="repeat 无限循环的重复执行"></a>repeat 无限循环的重复执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *_Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;signal A&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 使用 repeat 之后，将无限循环的接收信号</span><br><span class="line">[[[signal delay:1.0] repeat] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;testRepeat: %@&quot;, x); // 无限循环打印：testRepeat: signal A</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>由于使用 delay:1.0，所以会每隔 1 秒打印一次，如果不使用将会没有间隔的重复打印。</p><h3 id="throttle-节流"><a href="#throttle-节流" class="headerlink" title="throttle 节流"></a>throttle 节流</h3><p>当某个信号发送比较频繁时，可以使用节流，在某一段时间差不发送信号内容，过一段时间差后获取信号最新发出的内容，常用场景：</p><ol><li>阻止 “快速点击” 重复响应等问题。</li><li>输入框内容不是一变化就请求后台（后台扛不住)，可以延迟一会在请求或者输入很快可以让其快速只响应最终的结果。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[[subject throttle:0.5] subscribeNext:^(id _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;throttle: %@&quot;, x); // 打印：signalB、signalC、signalD、signalE</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject sendNext:@&quot;signalA&quot;];</span><br><span class="line">[subject sendNext:@&quot;signalB&quot;];</span><br><span class="line">// 1、signalA 和 signalB 之间间隔不足 0.5 秒，但是 signalB 与 signalC 间隔超过 0.5 秒，所以先打印 signalB</span><br><span class="line">// 2、signalC 和 signalD 之间间隔超过 0.5 秒，所以会打印 signalC</span><br><span class="line">// 3、signalD 和 signalE 之间间隔超过 0.5 秒，所以会打印 signalD</span><br><span class="line">// 4、signalE 之后没有了，所以会打印 signalE</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [subject sendNext:@&quot;signalC&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.9 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [subject sendNext:@&quot;signalD&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [subject sendNext:@&quot;signalE&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">打印：signalB、signalC、signalD、signalE</span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>signalA 和 signalB 之间间隔不足 0.5 秒，但是 signalB 与 signalC 间隔超过 0.5 秒，所以先打印 signalB。</li><li>signalC 和 signalD 之间间隔超过 0.5 秒，所以会打印 signalC。</li><li>signalD 和 signalE 之间间隔超过 0.5 秒，所以会打印 signalD。</li><li>signalE 之后没有了，所以会打印 signalE。</li></ol><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>给定一个信号数组 signal_array[N]，创建一个信号 zip_return，当订阅 zip_return 时，会等待 signal_array 中每一个信号都 sendNext:value 后，zip_return 才会 sendNext，zip_return 传出的值是 [value1, value2, ……, valueN];</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:</span><br><span class="line">                                   ^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                                       [subscriber sendNext:@&quot;signal A1&quot;];</span><br><span class="line">                                       [subscriber sendNext:@&quot;signal A2&quot;];</span><br><span class="line">                                       [subscriber sendCompleted];</span><br><span class="line">                                       return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                                           NSLog(@&quot;signalA dispose&quot;);</span><br><span class="line">                                       &#125;];</span><br><span class="line">                                   &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:</span><br><span class="line">                                    ^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                                        [subscriber sendNext:@&quot;signal B1&quot;];</span><br><span class="line">                                        [subscriber sendNext:@&quot;signal B2&quot;];</span><br><span class="line">                                        [subscriber sendNext:@&quot;signal B3&quot;];</span><br><span class="line">                                        [subscriber sendCompleted];</span><br><span class="line">                                        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                                            NSLog(@&quot;signalB dispose&quot;);</span><br><span class="line">                                        &#125;];</span><br><span class="line">                                    &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalC = [RACSignal createSignal:</span><br><span class="line">                      ^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                          [subscriber sendNext:@&quot;signal C1&quot;];</span><br><span class="line">//                              [subscriber sendNext:@&quot;signal C2&quot;];</span><br><span class="line">                          [subscriber sendCompleted];</span><br><span class="line">                          return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                              NSLog(@&quot;signalC dispose&quot;);</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line">[[RACSignal zip:@[ signalA, signalB, signalC ]] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;testZip: %@&quot;, x); // 打印元组 RACTuple</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 打印</span><br><span class="line">// 因为 signalC 只发出了一个信号，所以没法消耗掉其他的，只会有一组打印</span><br><span class="line">/*</span><br><span class="line"> testZip: &lt;RACTuple: 0x6000039c3e50&gt; (</span><br><span class="line"> &quot;signal A1&quot;,</span><br><span class="line"> &quot;signal B1&quot;,</span><br><span class="line"> &quot;signal C1&quot;</span><br><span class="line"> )</span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><p>可以看出来，他其实是 zipWith 的加强版本。</p><h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p>两个信号压缩！要两个信号都发出信号，会将其内容合并成一个元组给你，然后下一次触发条件依然是两个信号都有发送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RACSubject *subjectA = [RACSubject subject];</span><br><span class="line">RACSubject *subjectB = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">RACSignal *zipSignal = [subjectA zipWith:subjectB];</span><br><span class="line">[zipSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;testZipWith: %@&quot;, x); // 这里会压缩成一个元组</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subjectA sendNext:@&quot;subjectA 1&quot;];</span><br><span class="line">[subjectA sendNext:@&quot;subjectA 2&quot;];</span><br><span class="line">[subjectA sendNext:@&quot;subjectA 3&quot;];</span><br><span class="line"></span><br><span class="line">[subjectB sendNext:@&quot;subjectB 1&quot;];</span><br><span class="line">[subjectB sendNext:@&quot;subjectB 2&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 打印</span><br><span class="line">// 1: 当 subjectB 只发送了一个信号 @&quot;subjectB 1&quot;，他只会消耗 subjectA 一个信号 @&quot;subjectA 1&quot;，所以 subjectA 之后的两个信号是没法被消耗的。</span><br><span class="line">/*</span><br><span class="line"> testZipWith: &lt;RACTwoTuple: 0x600001983eb0&gt; (</span><br><span class="line"> &quot;subjectA 1&quot;,</span><br><span class="line"> &quot;subjectB 1&quot;</span><br><span class="line"> )</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">// 2: 如果 subjectB 发送了两个信号 @&quot;subjectB 1&quot;、@&quot;subjectB 2&quot;，他相应的就会消耗 subjectA 的两个信号。</span><br><span class="line">/*</span><br><span class="line"> testZipWith: &lt;RACTwoTuple: 0x600003ef1460&gt; (</span><br><span class="line"> &quot;subjectA 1&quot;,</span><br><span class="line"> &quot;subjectB 1&quot;</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> testZipWith: &lt;RACTwoTuple: 0x600003eec180&gt; (</span><br><span class="line"> &quot;subjectA 2&quot;,</span><br><span class="line"> &quot;subjectB 2&quot;</span><br><span class="line"> )</span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><h3 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h3><p>在发送消息之前，先发送一个消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;signal A&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;] startWith:@&quot;start with&quot;] subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">    NSLog(@&quot;testStartWith: %@&quot;, x); // 先打印：testStartWith: start with 然后在打印：testStartWith: signal A</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bind-绑定-包装&quot;&gt;&lt;a href=&quot;#bind-绑定-包装&quot; class=&quot;headerlink&quot; title=&quot;bind 绑定/包装&quot;&gt;&lt;/a&gt;bind 绑定/包装&lt;/h3&gt;&lt;p&gt;bind 主要作用属于包装，将信号返回的值包装成一个新的值，然后在通过信号返
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>RAC 常用总结</title>
    <link href="https://huangzhifei.github.io/2019/02/19/Objective-C/ReactiveObjc/RAC%20%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://huangzhifei.github.io/2019/02/19/Objective-C/ReactiveObjc/RAC 常用总结/</id>
    <published>2019-02-19T10:14:21.000Z</published>
    <updated>2020-01-05T02:55:03.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RAC-常用类"><a href="#RAC-常用类" class="headerlink" title="RAC 常用类"></a>RAC 常用类</h2><h3 id="1、RAC"><a href="#1、RAC" class="headerlink" title="1、RAC()"></a>1、RAC()</h3><p>用于给某个对象的某个属性绑定。把一个对象的某个属性绑定一个信号,只要发出信号,就会把信号的内容给对象的属性赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.collectionView, headArray)  = RACObserve(self.viewModel, headData);</span><br></pre></td></tr></table></figure><p>RAC(TARGET, [KEYPATH, [NIL_VALUE]]):用于给某个对象的某个属性绑定。</p><p>意思是：只要 self.viewModel 的 headData 内容改变 就会自动同步到 self.collectionView 的 headArray 上。</p><h3 id="2、RACObserve"><a href="#2、RACObserve" class="headerlink" title="2、RACObserve()"></a>2、RACObserve()</h3><p>用于给某个对象的某个属性绑定，快速的监听某个对象的某个属性改变，返回的是一个信号,对象的某个属性改变的信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[RACObserve(self.view, center) subscribeNext:^(id x) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>RACObserve(TARGET, KEYPATH):监听某个对象的某个属性,返回的是信号</p><p>意思是：只要 self.view 的 center 改变，就会触发他后面订阅的 subscribeNext: 然后触发回调。</p><h3 id="3、RACSignal-冷信号"><a href="#3、RACSignal-冷信号" class="headerlink" title="3、RACSignal 冷信号"></a>3、RACSignal 冷信号</h3><p>RACSignal 信号类表示当数据改变时，在信号内部会利用订阅者发送数据，他默认是一个冷信号，创建的时候是不会被触发的，只有被订阅以后才会变成热信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id subscriber) &#123;</span><br><span class="line"></span><br><span class="line">    // 3.block调用时刻：每当有订阅者订阅信号，就会调用block。</span><br><span class="line"></span><br><span class="line">    // 4.发送信号</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">    // 执行完信号后进行的清理工作，如果不需要就返回 nil</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span><br><span class="line"></span><br><span class="line">        // 执行完Block后，当前信号就不在被订阅了。</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;信号被销毁&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.订阅信号,才会激活信号.</span><br><span class="line">[siganl subscribeNext:^(id x) &#123;</span><br><span class="line">    // 5.block调用时刻：每当有信号发出数据，就会调用block.</span><br><span class="line">    NSLog(@&quot;接收到数据:%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4、RACSubscriber-订阅者"><a href="#4、RACSubscriber-订阅者" class="headerlink" title="4、RACSubscriber 订阅者"></a>4、RACSubscriber 订阅者</h3><p>RACSubscriber 是一个协议，任何遵循 RACSubscriber 协议的对象并且实现其协议方法都可以是一个订阅者，订阅者可以帮助信号发送数据，RACSubscriber 协议中有四个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@required</span><br><span class="line">- (void)sendNext:(nullable id)value;</span><br><span class="line">- (void)sendError:(nullable NSError *)error;</span><br><span class="line">- (void)sendCompleted;</span><br><span class="line">- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure><h3 id="5、RACDisposable-取消订阅、清理资源"><a href="#5、RACDisposable-取消订阅、清理资源" class="headerlink" title="5、RACDisposable 取消订阅、清理资源"></a>5、RACDisposable 取消订阅、清理资源</h3><p>RACDisposable 用于取消订阅和清理资源，当信号发送完成或发送错误时会自动调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    // 3.利用订阅者发送数据</span><br><span class="line">    [subscriber sendNext:@&quot;这是发送的数据&quot;];</span><br><span class="line">    // 如果为未调用,当信号发送完成或发送错误时会自动调用</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;资源被清理了&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.订阅信号</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">   NSLog(@&quot;接收到数据:%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>或者调用 RACDisposable 中的 dispose 方法来取消订阅。</p><h3 id="6、RACSubject-信号提供者"><a href="#6、RACSubject-信号提供者" class="headerlink" title="6、RACSubject 信号提供者"></a>6、RACSubject 信号提供者</h3><p>RACSubject 继承于 RACSignal，又遵循了 RACSubscriber 协议，所以既可以充当信号，又可以发送信号，通常用他代替代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">// 2.订阅信号</span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">    // block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">    NSLog(@&quot;testRACSubject 第一个订阅者%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">    // block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">    NSLog(@&quot;testRACSubject 第二个订阅者%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.发送信号</span><br><span class="line">[subject sendNext:@&quot;1&quot;];</span><br></pre></td></tr></table></figure><ol><li>RACSubject 底层实现和 RACSignal 不一样。</li><li>RACSubject 在执行 [RACSubject subject] 时，会在初始化时创建 disposable 对象属性和 subscribers 订阅者数组。</li><li>在执行 subscribeNext 订阅信号时，会创建一个订阅者 RACSubscriber，并将订阅者 RACSubscriber 添加到 subscribers 订阅者数组。</li><li>在执行 sendNext 发送信号时，会遍历 subscribers 订阅者数组，挨个执行 sendNext。</li></ol><h3 id="7、RACCommand-事件处理"><a href="#7、RACCommand-事件处理" class="headerlink" title="7、RACCommand 事件处理"></a>7、RACCommand 事件处理</h3><p>RACCommand 是处理事件的类，可以把事件如何处理，事件中的数据如何传递，包装到这个类中，可以很方便的监控事件的执行过程。</p><p>下面例子：监听按钮的点击，发送网络请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> // 1.创建命令</span><br><span class="line"> RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">     NSLog(@&quot;接收到命令:%@&quot;, input);</span><br><span class="line">     // 必须返回一个信号,不能为空.(信号中的信号)</span><br><span class="line">     // 3.创建信号用来传递数据</span><br><span class="line">     return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">         // 模拟网络加载</span><br><span class="line">[self loadData:^(id response) &#123;</span><br><span class="line">    // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span><br><span class="line">    [subscriber sendNext:response];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">&#125; fail:^(NSError *error) &#123;</span><br><span class="line">    [subscriber sendError:error];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">          return nil;</span><br><span class="line">     &#125;];</span><br><span class="line"> &#125;];</span><br><span class="line"> self.command = command;</span><br><span class="line"> </span><br><span class="line"> // 2.订阅 RACCommand 中的信号(必须要在执行命令前订阅)</span><br><span class="line"> [command.executionSignals subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;接收到信号中的信号发送的数据:%@&quot;,x);</span><br><span class="line">     // x 为信号中的信号</span><br><span class="line">[x subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">   // 此处的 x 才是网络请求到的数据</span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line"> &#125;];</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> // 4.执行命令</span><br><span class="line"> [command execute:@1];</span><br><span class="line"> </span><br><span class="line"> &lt;!--// 监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span><br><span class="line"> [[command.executing skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line">     if ([x boolValue] == YES) &#123;</span><br><span class="line">         NSLog(@&quot;正在执行&quot;);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         NSLog(@&quot;未开始/执行完成&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];--&gt;</span><br></pre></td></tr></table></figure><p>其中上述步骤 二 可以简化为下面方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到 RACCommand 中的信号</span><br><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line">    // 网络请求到的数据</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="RAC-常用用法"><a href="#RAC-常用用法" class="headerlink" title="RAC 常用用法"></a>RAC 常用用法</h2><h3 id="1、代替代理"><a href="#1、代替代理" class="headerlink" title="1、代替代理"></a>1、代替代理</h3><h4 id="使用-RACSubject-代替代理"><a href="#使用-RACSubject-代替代理" class="headerlink" title="使用 RACSubject 代替代理"></a>使用 RACSubject 代替代理</h4><p>场景：有一个 DelegateView 上面有一个 Button 按钮，通过实现代理来监听按钮的点击事件</p><p>1、先在 DelegateView.h 里面定义一个 RACSubject 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) RACSubject *btnClickSignal;</span><br><span class="line"></span><br><span class="line">- (RACSubject *)btnClickSignal &#123;</span><br><span class="line">    if (!_btnClickSignal) &#123;</span><br><span class="line">        _btnClickSignal = [RACSubject subject];</span><br><span class="line">    &#125;</span><br><span class="line">    return _btnClickSignal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在 Button 按钮的点击事件中触发此信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl *_Nullable x) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self.btnClickSignal sendNext:@&quot;我在代理&quot;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>3、在 ViewController 中订阅此信号就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.delegateView.btnClickSignal subscribeNext:^(id _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;button: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="使用-rac-signalForSelector-方法代替代理"><a href="#使用-rac-signalForSelector-方法代替代理" class="headerlink" title="使用 rac_signalForSelector 方法代替代理"></a>使用 rac_signalForSelector 方法代替代理</h4><p>原理：判断一个方法有没有调用，如果调用了就会自动发送一个信号。</p><p>1、给此 button 添加响应函数</p><pre><code>[self.btn addTarget:self action:@selector(buttonClick:) forControlEvents:UIControlEventTouchUpInside];- (void)buttonClick:(UIButton *)sender {    NSLog(@&quot;xxxxxx&quot;);}</code></pre><p>2、在 ViewController 中使用 rac_signalForSelector 订阅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[self.delegateView rac_signalForSelector:@selector(buttonClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;button2: %@&quot;, x);</span><br><span class="line">        UIButton *btn = (UIButton *)x[0];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上面说了原理是：只要 @selector 中的方法被调用就可以触发 rac_signalForSelector 来监听，所以其实第一步不一定非得使用 addTarget:action: 来触发调用，我们用下面方式来触发也能达到效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@weakify(self);</span><br><span class="line">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl *_Nullable x) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self buttonClick:self.btn];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="2、代替-KVO"><a href="#2、代替-KVO" class="headerlink" title="2、代替 KVO"></a>2、代替 KVO</h3><p>不用在像以前那样代码分离的写很多代码，直接使用 rac_valuesAndChangesForKeyPath </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[self.delegateView rac_valuesAndChangesForKeyPath:@&quot;backgroundColor&quot;</span><br><span class="line">                                               options:NSKeyValueObservingOptionNew observer:nil]</span><br><span class="line">     subscribeNext:^(id x) &#123;</span><br><span class="line">         NSLog(@&quot;self.delegateView: %@&quot;,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h3 id="3、代替-Control-Event"><a href="#3、代替-Control-Event" class="headerlink" title="3、代替 Control Event"></a>3、代替 Control Event</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl *_Nullable x) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4、代替通知（NSNotificationCenter）"><a href="#4、代替通知（NSNotificationCenter）" class="headerlink" title="4、代替通知（NSNotificationCenter）"></a>4、代替通知（NSNotificationCenter）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;键盘弹出&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="5、监听文本框文字改变"><a href="#5、监听文本框文字改变" class="headerlink" title="5、监听文本框文字改变"></a>5、监听文本框文字改变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[self.textField rac_textSignal] subscribeNext:^(NSString *_Nullable value) &#123;</span><br><span class="line">@strongify(self);</span><br><span class="line">self.label.text = value;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="6、rac-liftSelector-多次请求全部完成才触发"><a href="#6、rac-liftSelector-多次请求全部完成才触发" class="headerlink" title="6、rac_liftSelector 多次请求全部完成才触发"></a>6、rac_liftSelector 多次请求全部完成才触发</h3><p>处理当界面有多次请求时，需要都获取到数据时，才能展示界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rac_liftSelector:withSignalsFromArray:Signals:</span><br></pre></td></tr></table></figure><p>当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</p><p>注意：</p><p>有几个信号，参数一的方法就有几个参数，每个参数对应信号发出的数据。<br>不需要主动去订阅 signalA、signalB ……,方法内部会自动订阅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    double delayInSeconds = 2.0;</span><br><span class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">        [subscriber sendNext:@&quot;A&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&quot;B&quot;];</span><br><span class="line">    [subscriber sendNext:@&quot;Another B&quot;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self rac_liftSelector:@selector(doA:withB:) withSignals:signalA, signalB, nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 响应方法</span><br><span class="line">- (void)doA:(NSString *)A withB:(NSString *)B &#123;</span><br><span class="line">    NSLog(@&quot;A:%@ and B:%@&quot;, A, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A:A and B:Another B</span><br></pre></td></tr></table></figure><p>signalB 第一次发送的内容 @“B” 被后面的 @”Another B” 覆盖，因为要等 signalA 也发送一次后，才能触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RAC-常用类&quot;&gt;&lt;a href=&quot;#RAC-常用类&quot; class=&quot;headerlink&quot; title=&quot;RAC 常用类&quot;&gt;&lt;/a&gt;RAC 常用类&lt;/h2&gt;&lt;h3 id=&quot;1、RAC&quot;&gt;&lt;a href=&quot;#1、RAC&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="RAC" scheme="https://huangzhifei.github.io/categories/RAC/"/>
    
    
      <category term="RAC" scheme="https://huangzhifei.github.io/tags/RAC/"/>
    
  </entry>
  
  <entry>
    <title>Xcode10 build和install慢的两个解决方法</title>
    <link href="https://huangzhifei.github.io/2018/11/19/Objective-C/XCode%20%E7%9B%B8%E5%85%B3/Xcode10%20build%E5%92%8Cinstall%E6%85%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://huangzhifei.github.io/2018/11/19/Objective-C/XCode 相关/Xcode10 build和install慢的两个解决方法/</id>
    <published>2018-11-19T01:46:26.000Z</published>
    <updated>2020-01-05T02:55:03.371Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Xcode 的更新和工程项目代码的增加，Xcode 在 build 的时候会显得越来越慢，尤其是在升级到 Xcode 10 之后，通过搜集一些资料与尝试，总结如下两点。</p><h3 id="将-Debug-Information-Format-改为-DWARF"><a href="#将-Debug-Information-Format-改为-DWARF" class="headerlink" title="将 Debug Information Format 改为 DWARF"></a>将 Debug Information Format 改为 DWARF</h3><pre><code>在工程 Project 以及对应 Target 的 Build Settings 中，找到 Debug Information Format 这一项，将 Debug 时的 DWARF with dSYM file 改为DWARF。</code></pre><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Debug-Information-Format.png" alt=""></p><pre><code>原因 :这一项设置的是是否将调试信息加入到可执行文件中，改为DWARF后，如果程序崩溃，将无法输出崩溃位置对应的函数堆栈，但由于Debug模式下可以在XCode中查看调试信息，所以改为DWARF影响并不大。这一项更改完之后，可以大幅提升编译速度。 亲测这一项改动卓有成效</code></pre><h3 id="将-Build-Active-Architecture-Only-改为-Yes"><a href="#将-Build-Active-Architecture-Only-改为-Yes" class="headerlink" title="将 Build Active Architecture Only 改为 Yes"></a>将 Build Active Architecture Only 改为 Yes</h3><pre><code>在工程对应 Target 的 Build Settings 中，找到 Build Active Architecture Only 这一项，将Debug时的No改为Yes。</code></pre><p><img src="https://github.com/huangzhifei/blog-web/raw/master/source/_posts/images/Build-Active-Architecture-Only.png" alt=""></p><pre><code>原因 :这一项设置的是是否仅编译当前架构的版本，如果为No，会编译所有架构的版本。需要注意的是，此选项在Release模式下必须为Yes，否则发布的ipa在部分设备上将不能运行。这一项更改完之后，可以显著提高编译速度。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着 Xcode 的更新和工程项目代码的增加，Xcode 在 build 的时候会显得越来越慢，尤其是在升级到 Xcode 10 之后，通过搜集一些资料与尝试，总结如下两点。&lt;/p&gt;
&lt;h3 id=&quot;将-Debug-Information-Format-改为-DWARF&quot;&gt;
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>podspec 文件基础模块说明</title>
    <link href="https://huangzhifei.github.io/2018/10/20/Objective-C/CocoaPods/podspec%20%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E8%AF%B4%E6%98%8E/"/>
    <id>https://huangzhifei.github.io/2018/10/20/Objective-C/CocoaPods/podspec 文件基础模块说明/</id>
    <published>2018-10-20T06:28:48.000Z</published>
    <updated>2020-01-05T02:55:03.369Z</updated>
    
    <content type="html"><![CDATA[<p>参照官方文档:<a href="">http://guides.cocoapods.org/syntax/podspec.html</a></p><p>文件内容可以根据模板和注释来修改和填写，对其中一些内容进行记录说明</p><h4 id="s-source-files"><a href="#s-source-files" class="headerlink" title="s.source_files"></a>s.source_files</h4><p>指明哪些源文件会被包含进去，比如s.source_files = “KMPinHeaderLayout/Classes/**/*.{h,m}”，多条之间用逗号,分隔，用**表示匹配所有子目录，用*表示匹配所有文件，.{h,m}表示匹配其中的.h和.m文件。其中的路径是以.podspec所在目录为根目录。</p><h4 id="s-exclude-files"><a href="#s-exclude-files" class="headerlink" title="s.exclude_files"></a>s.exclude_files</h4><p>规则同上，指定不被包含的文件、目录。</p><h4 id="s-license"><a href="#s-license" class="headerlink" title="s.license"></a>s.license</h4><p>一般写法有s.license = ‘MIT’ 或 s.license = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ }， LICENSE对应.podspec所在目录下的名为LICENSE文件</p><h4 id="s-platform"><a href="#s-platform" class="headerlink" title="s.platform"></a>s.platform</h4><p>指定可用平台和版本，s.platform = :ios, “7.0”，s.ios.deployment_target = ‘7.0’。如果支持多个平台应该使用后者，并指定其他平台的版本如s.osx.deployment_target = “10.7”。</p><h4 id="s-public-header-files"><a href="#s-public-header-files" class="headerlink" title="s.public_header_files"></a>s.public_header_files</h4><p>公开的头文件，如果指定，在pod lint验证时，会以framework的形式验证，一般可以不用这个配置</p><h4 id="s-framework-s-、s-libraries"><a href="#s-framework-s-、s-libraries" class="headerlink" title="s.framework(s)、s.libraries"></a>s.framework(s)、s.libraries</h4><p>指定依赖的系统库。两者内容都需要去除后缀，其中s.libraries需要去除前缀lib，如静态库依赖是libz.tbd，则s.libraries = ‘z’。</p><h4 id="s-vendored-libraries-、s-vendored-frameworks"><a href="#s-vendored-libraries-、s-vendored-frameworks" class="headerlink" title="s.vendored_libraries 、s.vendored_frameworks"></a>s.vendored_libraries 、s.vendored_frameworks</h4><p>如果开源库中是一个静态库，使用这个指定静态库。如微博的podspec中s.vendored_libraries = ‘libWeiboSDK/libWeiboSDK.a’</p><h4 id="s-xcconfig"><a href="#s-xcconfig" class="headerlink" title="s.xcconfig"></a>s.xcconfig</h4><p>指定项目配置，如HEADER_SEARCH_PATHS 、OTHER_LDFLAGS等，e.g s.xcconfig = { “OTHER_LDFLAGS” =&gt; “-ObjC” }</p><h4 id="s-resource"><a href="#s-resource" class="headerlink" title="s.resource"></a>s.resource</h4><p>指定包含的资源文件 bundle</p><pre><code>spec.resource = &apos;Resources/HockeySDK.bundle&apos;</code></pre><p>可以参照 MJRefresh.podspec</p><h4 id="s-resources"><a href="#s-resources" class="headerlink" title="s.resources"></a>s.resources</h4><p>指定包含的资源文件 (图片、音视频、storyboard,xib,png,plist,xcassets,lproj等）</p><pre><code>spec.resources = [&apos;Images/*.png&apos;, &apos;Sounds/*&apos;]或spec.resources = &apos;test/**/*.{storyboard,xib,png,plist,xcassets,lproj}&apos;</code></pre><p>这些资源文件在 build 时会被直接拷贝到 client target 的 mainBundle 里,这样就实现了把图片、音频、NIB等资源打包进最终应用程序<br>的目的。但是，这就带来了一个问题，那就是 client target 的资源和各种 pod 所带来的资源都在同一 bundle 的同一层目录下，很容易产生命名冲突。例如，我的 app 里有张按钮图片叫 “button.png”，而你的 pod 里也有张图片叫 “button.png”，拷贝资源时，我很担心 pod 里的文件会不会把我 app 里的同名文件给覆盖掉。</p><h4 id="s-dependency"><a href="#s-dependency" class="headerlink" title="s.dependency"></a>s.dependency</h4><p>指定依赖，如s.dependency = ‘AFNetworking’</p><h4 id="s-source"><a href="#s-source" class="headerlink" title="s.source"></a>s.source</h4><p>指定源，s.source = { :git =&gt; ‘<a href="https://github.com/sleepEarlier/PinHeaderLayout.git&#39;" target="_blank" rel="noopener">https://github.com/sleepEarlier/PinHeaderLayout.git&#39;</a>, :tag =&gt; s.version.to_s }</p><h4 id="使用三方-a-或-framework-的样例"><a href="#使用三方-a-或-framework-的样例" class="headerlink" title="使用三方 .a 或 .framework 的样例"></a>使用三方 .a 或 .framework 的样例</h4><p>拿微信当作例子</p><p>1、先从微信开放平台下载微信sdk</p><p>2、在NCKFoundation/NCKFoundation/Classes 目录下创建ThirdParty文件夹，并将.a和.h文件拖到ThirdParty文件夹下。（注意不要拖到工程目录下，而是文件目录）在podspec文件里修改source_file 为</p><pre><code>spec.source_files = &apos;NCKFoundation/Classes/*.{h,m}&apos;, &apos;NCKFoundation/Classes/ThirdParty/*.{h}&apos;</code></pre><p>3、添加.a静态库的依赖,.a依赖的系统framework以及library</p><pre><code>spec.vendored_libraries  = &apos;NCKFoundation/Classes/ThirdParty/*.{a}&apos;spec.frameworks =     &apos;SystemConfiguration&apos;,&apos;CoreGraphics&apos;,&apos;CoreTelephony&apos;,&apos;Security&apos;,&apos;CoreLocation&apos;,&apos;JavaScriptCore&apos;spec.libraries  = &apos;iconv&apos;,&apos;sqlite3&apos;,&apos;stdc++&apos;,&apos;z&apos;</code></pre><p>4、参数说明</p><pre><code>vendored_libraries: 第三方.a文件frameworks: 该pod依赖的系统frameworklibraries: 该pod依赖的系统library</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照官方文档:&lt;a href=&quot;&quot;&gt;http://guides.cocoapods.org/syntax/podspec.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文件内容可以根据模板和注释来修改和填写，对其中一些内容进行记录说明&lt;/p&gt;
&lt;h4 id=&quot;s-source-files
      
    
    </summary>
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/categories/CocoaPods/"/>
    
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>开发模式下测试pod库的代码</title>
    <link href="https://huangzhifei.github.io/2018/10/19/Objective-C/CocoaPods/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%8B%E8%AF%95pod%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://huangzhifei.github.io/2018/10/19/Objective-C/CocoaPods/开发模式下测试pod库的代码/</id>
    <published>2018-10-19T06:14:04.000Z</published>
    <updated>2020-01-05T02:55:03.369Z</updated>
    
    <content type="html"><![CDATA[<p>参照文章 <a href="">http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/</a></p><p>前期版本肯定会有大的升级与维护，如何方便的测试？</p><p>自己可以创建一个新项目，在Podfile中指定自己编辑好的podspec文件，如下：（两种方式填写一种就行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;ZJPodPrivateTest&apos;, :path =&gt; &apos;~/Desktop/ZJPodPrivateTest&apos;      # 指定路径</span><br><span class="line"># pod &apos;PodTestLibrary&apos;, :podspec =&gt; &apos;~/Desktop/ZJPodPrivateTest/ZJPodPrivateTest.podspec&apos;  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后执行 pod update 命令安装，然后打开项目发现库文件已经被加载到 Pods 子项目中了，不过没有在 Pods 目录下，而是在 Development Pods/ZJPodPrivateTest 目录下，因为是本地测试项目，没有把 podspec 文件添加到 Spec Repo 中的缘故。</p><p>通过这种方式集成后，我们可以很方便的更改 Development Pods/ZJPodPrivateTest 下面的内容从而同步到对应的源文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照文章 &lt;a href=&quot;&quot;&gt;http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前期版本肯定会有大的升级与维护，如何方便的测试？&lt;/p&gt;
&lt;p&gt;自己可以创建一个新项目，在P
      
    
    </summary>
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/categories/CocoaPods/"/>
    
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>pod的常用命令及参数</title>
    <link href="https://huangzhifei.github.io/2018/10/17/Objective-C/CocoaPods/pod%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%8F%82%E6%95%B0/"/>
    <id>https://huangzhifei.github.io/2018/10/17/Objective-C/CocoaPods/pod的常用命令及参数/</id>
    <published>2018-10-17T05:47:30.000Z</published>
    <updated>2020-01-05T02:55:03.369Z</updated>
    
    <content type="html"><![CDATA[<p>参照官方文档 <a href="https://guides.cocoapods.org/terminal/commands.html" target="_blank" rel="noopener">CocoaPods 官方文档</a></p><h3 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h3><pre><code>pod repo add DSSPecs https://github.com/walkdianzi/DSSpecs.git</code></pre><h3 id="删除仓库"><a href="#删除仓库" class="headerlink" title="删除仓库"></a>删除仓库</h3><pre><code>pod repo remove DSSPecs</code></pre><h3 id="更新仓库"><a href="#更新仓库" class="headerlink" title="更新仓库"></a>更新仓库</h3><pre><code>pod repo update DSSpecs</code></pre><h3 id="查看当前安装的pod仓库"><a href="#查看当前安装的pod仓库" class="headerlink" title="查看当前安装的pod仓库"></a>查看当前安装的pod仓库</h3><pre><code>pod repo</code></pre><h3 id="提交-podspec"><a href="#提交-podspec" class="headerlink" title="提交.podspec"></a>提交.podspec</h3><pre><code>pod repo push DSSpecs xxxx.podspec</code></pre><h3 id="验证-podspec文件"><a href="#验证-podspec文件" class="headerlink" title="验证.podspec文件"></a>验证.podspec文件</h3><pre><code>pod lib lint name.podspecpod spec lint name.podspec</code></pre><p>pod spec相对于pod lib会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。</p><h3 id="sources"><a href="#sources" class="headerlink" title="- -sources"></a>- -sources</h3><p>当你的.podspec文件依赖其他私有库时要引入source</p><pre><code>pod lib lint name.podspec --sources=&apos;https://github.com/walkdianzi/DSSpecs&apos;</code></pre><p>或者直接用仓库名,就是~/.cocoapods/repos/文件夹下对应仓库的名字</p><pre><code>pod lib lint name.podspec --sources=DSSPecs,master</code></pre><h3 id="no-repo-update"><a href="#no-repo-update" class="headerlink" title="- -no-repo-update"></a>- -no-repo-update</h3><p>有时候当你使用pod update时会发现特别慢，那是因为pod会默认先更新一次podspec索引。使用- -no-repo-update参数可以禁止其做索引更新操作。</p><pre><code>pod update --no-repo-update</code></pre><p>和git一样，本地有个pod repo，和github上的版本对应，如果你不想更新这个的话后面加上- -no-repo-update就可以了，但是这样会有个问题，如果github上pods的一些插件像AF有新版本了，你本地搜索的af还是旧版本如果用的新版本号是无法装配的，所以每隔一段时间我都会执行一下pod repo update。</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="- -verbose"></a>- -verbose</h3><p>打印详细信息</p><h3 id="only-errors和-allow-warnings"><a href="#only-errors和-allow-warnings" class="headerlink" title="- -only-errors和- -allow-warnings"></a>- -only-errors和- -allow-warnings</h3><ul><li><p>-allow-warnings是允许warning的存在，也就是说当你在pod lib lint验证podspec的时候，如果不加这句，而你的代码里又一些警告的话，是验证不通过的。而加上这句话的话，有警告也能验证通过。</p></li><li><p>-only-errors这句话是只显示出错误，就是你在验证的时候就算- -allow-warnings，但是那些warnings也还是会打印出来和errors混杂在一起，这会让你很难找error。所以这里使用- -only-errors来只打印error，不打印warning。</p></li></ul><h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="- -fail-fast"></a>- -fail-fast</h3><p>出现第一个错误的时候就停止</p><p>这个参数非常好用，默认出现出错后，他是不会停下来的，如果是 podspec 里面模块很多，会花费大量的时间。</p><h3 id="use-libraries"><a href="#use-libraries" class="headerlink" title="- -use-libraries"></a>- -use-libraries</h3><p>pod在提交或验证的时候如果用到的第三方中需要使用.a静态库文件的话，则会用到这个参数。如果不使用- -use-libraries则会验证不通过。</p><p>但是比如你用swift创建了一个pod的话，你使用- -use-libraries就会报错，因为swift开始，生成的就不是.a静态库了，它是不支持编译为静态库的，只能生成.Framework动态库。</p><h3 id="完整的命令"><a href="#完整的命令" class="headerlink" title="完整的命令"></a>完整的命令</h3><pre><code>pod repo push eric-specs AAA.podspec --allow-warnings --verbose --sources=&apos;http://test.git,https://github.com/CocoaPods/Specs&apos;pod lib lint test.podspec --no-clean --allow-warnings --verbose --fail-fast --sources=&apos;http://test.git,https://github.com/CocoaPods/Specs&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照官方文档 &lt;a href=&quot;https://guides.cocoapods.org/terminal/commands.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaPods 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加仓库&quot;&gt;
      
    
    </summary>
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/categories/CocoaPods/"/>
    
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>podspec的subspec使用</title>
    <link href="https://huangzhifei.github.io/2018/10/17/Objective-C/CocoaPods/podspec%E7%9A%84subspec%E4%BD%BF%E7%94%A8/"/>
    <id>https://huangzhifei.github.io/2018/10/17/Objective-C/CocoaPods/podspec的subspec使用/</id>
    <published>2018-10-17T03:05:05.000Z</published>
    <updated>2020-01-05T02:55:03.369Z</updated>
    
    <content type="html"><![CDATA[<p>参照官方文档 <a href="https://guides.cocoapods.org/syntax/podspec.html#group_subspecs" target="_blank" rel="noopener">subspec</a></p><h3 id="预处理宏配置"><a href="#预处理宏配置" class="headerlink" title="预处理宏配置"></a>预处理宏配置</h3><h4 id="什么是预处理"><a href="#什么是预处理" class="headerlink" title="什么是预处理"></a>什么是预处理</h4><p>上一段 JSPatch 的经典代码</p><pre><code>[JSPatch startWithAppKey:@&quot;YOU_GUESS&quot;];#ifdef DEBUG[JSPatch setupDevelopment];#endif[JSPatch sync];</code></pre><p>上面代码中那个 DEBUG 就是预处理宏，这是编译器给我们内置好了的，我们可以自己定义一个，但是我们使用外部第三方的时候，可能并不知道要定义什么样子的预编译宏，如果外部能帮我们做那不太好了，cocoapods 就可以。</p><h4 id="subspec-配置预编译宏"><a href="#subspec-配置预编译宏" class="headerlink" title="subspec 配置预编译宏"></a>subspec 配置预编译宏</h4><p>一个第三方库会有很多功能，其中有一部分功能需要在编译阶段就决定是否引入。比如 IDFA，Apple 要求使用的话需要在提交审核的时候声明，不然就被拒。此时如果应用不用，那就会被你拖累。所以需要提供一个方法从代码里删除，这就需要用到预处理宏。用类似上面的方式改好后，让用户在 Build Settings 里设置一下就 OK。<br>如果这个库支持 CocoaPods，可以建一个 subspec 省去用户手动修改：</p><pre><code>s.subspec &apos;IDFA&apos; do |f|  f.dependency &apos;YOUR_SPEC/core&apos;  f.pod_target_xcconfig = { &apos;GCC_PREPROCESSOR_DEFINITIONS&apos; =&gt; &apos;ENABLE_IDFA=1&apos;}end</code></pre><p>可以多看看 FMDB、SDWebImage 等流行库的 podspec 写法。</p><p>当有多个预处理宏需要设置，可以都写在这一个里面。<br>可如果不想写在一起，想让用户自己选择开启某些的话，怎么办？<br>答案很简单，多写几个 subspec。用户需要哪个，就引入哪个。</p><h3 id="subspec-的模块化配置"><a href="#subspec-的模块化配置" class="headerlink" title="subspec 的模块化配置"></a>subspec 的模块化配置</h3><p>使用 subspec 可以实现良好的代码分层，依赖也更清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  #设置 podspec 的默认 subspec</span><br><span class="line">  s.default_subspec = &apos;core&apos;</span><br><span class="line">  #主要 subspec</span><br><span class="line">  s.subspec &apos;core&apos; do |c|</span><br><span class="line">    c.source_files  = &quot;*.&#123;h,m&#125;&quot;</span><br><span class="line">    c.public_header_files = &quot;*.h&quot;</span><br><span class="line">    c.frameworks = &apos;UIKit&apos;,</span><br><span class="line">    c.libraries = &apos;icucore&apos;, &apos;sqlite3&apos;, &apos;z&apos;</span><br><span class="line">    c.platform = :ios, &quot;7.0&quot;</span><br><span class="line">  end</span><br><span class="line">  #功能1，引入则开启</span><br><span class="line">  s.subspec &apos;IDFA&apos; do |f|</span><br><span class="line">    # 子模块的个自的源码路径</span><br><span class="line">    f.source_files = &apos;FSLib/**/*&apos;</span><br><span class="line">    # 子模块要暴露的头文件</span><br><span class="line">    f.public_header_files=&apos;FSLib/A/A.h&apos;</span><br><span class="line">    f.dependency &apos;YOUR_SPEC/core&apos;</span><br><span class="line">    f.xcconfig = &#123; &apos;GCC_PREPROCESSOR_DEFINITIONS&apos; =&gt; &apos;ENABLE_IDFA=1&apos;&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  #功能2，引入则开启</span><br><span class="line">  s.subspec &apos;IDFB&apos; do |f|</span><br><span class="line">    f.dependency &apos;YOUR_SPEC/core&apos;</span><br><span class="line">    f.xcconfig = &#123; &apos;GCC_PREPROCESSOR_DEFINITIONS&apos; =&gt; &apos;ENABLE_IDFB=1&apos;&#125;</span><br><span class="line">  end  </span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里面通过两个 subpec 来开关功能。当用户用的时候，则在 Podfile 里这么引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 远程引用</span><br><span class="line">pod &apos;YOUR_SPEC&apos;, :subspecs =&gt; [&apos;IDFA&apos;, &apos;IDFB&apos;] 或</span><br><span class="line">pod &apos;YOUR_SPEC&apos;, &apos;0.1.2&apos;, :subspecs =&gt; [&apos;IDFA&apos;, &apos;IDFB&apos;]</span><br><span class="line"></span><br><span class="line"># 本地相对路径引用</span><br><span class="line">pod &apos;YOUR_SPEC&apos;, :path =&gt;&apos;../../sources&apos; , :subspecs =&gt; [&apos;IDFA&apos;, &apos;IDFB&apos;]</span><br></pre></td></tr></table></figure><p>通过上面的方式就能控制 pod 下来是哪个 subspec 的代码，不用把整个都 pod 下来，也能自动配置好预处理宏。</p><h3 id="subspec-常用三方库的使用"><a href="#subspec-常用三方库的使用" class="headerlink" title="subspec 常用三方库的使用"></a>subspec 常用三方库的使用</h3><p>一般一个大的项目写成pod的时候，它可能会分为多个subspec，这样的话当你用一个庞大的库时，只需要其中的一小部分，那么就可以使用其中的某个subspec了。我们拿AFNetworking.podspec来看，比如只引入其中的Reachability：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;AFNetworking/Reachability&apos;</span><br><span class="line">或者</span><br><span class="line">pod &apos;AFNetworking&apos;,:subspecs=&gt;[&apos;Reachability&apos;,&apos;Security&apos;]</span><br></pre></td></tr></table></figure><p>所以一般subspec之间最好不要有互相依赖，不然的话，你用了其中一个subspec，而它其中一个文件依赖了另一个你未引入的subspec中的文件的话是会报错的。</p><p>如果有多个subspec互相依赖的话，可以像AFNetworking.podspec里这样写，UIKit依赖于NSURLSession:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s.subspec &apos;NSURLSession&apos; do |ss|</span><br><span class="line">    //省略一大段代码</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;UIKit&apos; do |ss|</span><br><span class="line">    ss.ios.deployment_target = &apos;7.0&apos;</span><br><span class="line">    ss.tvos.deployment_target = &apos;9.0&apos;</span><br><span class="line">    ss.dependency &apos;AFNetworking/NSURLSession&apos;</span><br><span class="line"></span><br><span class="line">    ss.public_header_files = &apos;UIKit+AFNetworking/*.h&apos;</span><br><span class="line">    ss.source_files = &apos;UIKit+AFNetworking&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>所以可以把subspec当做一个小型的pod来看，我们可以看一下pod AFNetworking安装之后，Podfile.lock中的pod安装目录。可以看出那些subspec也算是一个pod。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PODS:</span><br><span class="line">  - AFNetworking (3.0.0):</span><br><span class="line">    - AFNetworking/NSURLSession (= 3.0.0)</span><br><span class="line">    - AFNetworking/Reachability (= 3.0.0)</span><br><span class="line">    - AFNetworking/Security (= 3.0.0)</span><br><span class="line">    - AFNetworking/Serialization (= 3.0.0)</span><br><span class="line">    - AFNetworking/UIKit (= 3.0.0)</span><br><span class="line">  - AFNetworking/NSURLSession (3.0.0):</span><br><span class="line">    - AFNetworking/Reachability</span><br><span class="line">    - AFNetworking/Security</span><br><span class="line">    - AFNetworking/Serialization</span><br><span class="line">  - AFNetworking/Reachability (3.0.0)</span><br><span class="line">  - AFNetworking/Security (3.0.0)</span><br><span class="line">  - AFNetworking/Serialization (3.0.0)</span><br><span class="line">  - AFNetworking/UIKit (3.0.0):</span><br><span class="line">    - AFNetworking/NSURLSession</span><br><span class="line">DEPENDENCIES:</span><br><span class="line">  - AFNetworking (= 3.0)</span><br><span class="line">SPEC CHECKSUMS:</span><br><span class="line">  AFNetworking: 932ff751f9d6fb1dad0b3af58b7e3ffba0a4e7fd</span><br><span class="line"></span><br><span class="line">PODFILE CHECKSUM: f38d14cf91adf9e2024f841ce5336dae96aa6fa6</span><br><span class="line"></span><br><span class="line">COCOAPODS: 1.6.0.beta.1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照官方文档 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html#group_subspecs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;subspec&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;预
      
    
    </summary>
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/categories/CocoaPods/"/>
    
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods 私有库搭建</title>
    <link href="https://huangzhifei.github.io/2018/10/12/Objective-C/CocoaPods/CocoaPods%20%E7%A7%81%E6%9C%89%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>https://huangzhifei.github.io/2018/10/12/Objective-C/CocoaPods/CocoaPods 私有库搭建/</id>
    <published>2018-10-12T08:07:58.000Z</published>
    <updated>2020-01-05T02:55:03.368Z</updated>
    
    <content type="html"><![CDATA[<p>参照官方文档 <a href="https://guides.cocoapods.org/terminal/commands.html#pod_repo_push" target="_blank" rel="noopener">CocoaPods 官方文档</a></p><h3 id="一、创建两个-git-仓库"><a href="#一、创建两个-git-仓库" class="headerlink" title="一、创建两个 git 仓库"></a>一、创建两个 git 仓库</h3><p>我们创建两个 git 仓库，一个用来做私有 Spec Repo，一个是我们自己的公共组件：</p><p>第一个仓库名称是 Spec，专门用来做私有Spec Repo。</p><p>第二个仓库名称是 BGNetwork，这个就是我们公共组件库。</p><p>在这里，我们来说一下什么是Spec Repo?</p><pre><code>他是所有的 Pods 的一个索引，就是一个容器，所有公开的 Pods 都在这个里面，他实际是一个 Git 仓库 remote 端。在 GitHub 上，当你使用了 Cocoapods 后他会被 clone 到本地的 ~/.cocoapods/repos 目录下，可以进入到这个目录看到 master 文件夹就是这个官方的 Spec Repo 了。</code></pre><h3 id="二、添加私有Spec-repo（索引库）-到-Cocoapods"><a href="#二、添加私有Spec-repo（索引库）-到-Cocoapods" class="headerlink" title="二、添加私有Spec repo（索引库） 到 Cocoapods"></a>二、添加私有Spec repo（索引库） 到 Cocoapods</h3><p>主要命令是pod repo add REPO_NAME SOURCE_URL。其中，REPO_NAME 是私有 repo 的名字，取一个容易记住的名字，后面还会用到，以后公司内部的组件对应的 podspec 都可以推送到这个 repo 中；SOURCE_URL 就是刚刚我们创建的 Spec 仓库链接。</p><pre><code>$ pod repo add eric https://github.com/eric/Spec.git$ ls ~/.cocoapods/repos    eric    master</code></pre><p>这时，你会发现有两个文件夹 eric 和 master，master 是 Cocoapods 官方的 repo，而 eric 就是我刚刚创建的。<br>进入 eric 文件夹查看，你会发现它是 clone 了一份 <a href="https://github.com/eric/Spec.git。" target="_blank" rel="noopener">https://github.com/eric/Spec.git。</a></p><p>在这里，我们是一个空的仓库，可以不检查，但是你的仓库如果有什么其他东西的话，可以检查一下。</p><pre><code>$ cd ~/.cocoapods/repos/eric$ pod repo lint .</code></pre><h3 id="三、制作自己的公共组件"><a href="#三、制作自己的公共组件" class="headerlink" title="三、制作自己的公共组件"></a>三、制作自己的公共组件</h3><h4 id="1、将我们前面创建的-BGNetwork-项目克隆到本地"><a href="#1、将我们前面创建的-BGNetwork-项目克隆到本地" class="headerlink" title="1、将我们前面创建的 BGNetwork 项目克隆到本地"></a>1、将我们前面创建的 BGNetwork 项目克隆到本地</h4><pre><code>$ git clone https://github.com/eric/BGNetwork.git</code></pre><h4 id="2、在本地我们使用了-xcode-创建了项目，并且写了一个网络框架，运行没有问题，我们准备提交到-github，并打上版本号。"><a href="#2、在本地我们使用了-xcode-创建了项目，并且写了一个网络框架，运行没有问题，我们准备提交到-github，并打上版本号。" class="headerlink" title="2、在本地我们使用了 xcode 创建了项目，并且写了一个网络框架，运行没有问题，我们准备提交到 github，并打上版本号。"></a>2、在本地我们使用了 xcode 创建了项目，并且写了一个网络框架，运行没有问题，我们准备提交到 github，并打上版本号。</h4><pre><code>$ git add .$ git commit -m &apos;add file&apos;$ git push origin master$ git tag -m &apos;add tag&apos; &apos;0.1.1&apos;$ git push --tags</code></pre><h4 id="3、我们开始制作-Podspec-文件。"><a href="#3、我们开始制作-Podspec-文件。" class="headerlink" title="3、我们开始制作 Podspec 文件。"></a>3、我们开始制作 Podspec 文件。</h4><p>BGNetwork 是一个基于 AFNetworking 而封装的网络框架，它主要的源文件都在 BGNetwork/BGNetwork 路径下。我们将它放在 CocoaPods 给第三方使用，主要是将这个文件夹下的源文件加载到第三方的项目中以供使用。<br>下面是供第三方使用的源文件结构，具体可以下载 BGNetwork 代码查看</p><pre><code>____BGNetwork| |____BGAFHTTPClient.h| |____BGAFHTTPClient.m| |____BGAFRequestSerializer.h| |____BGAFRequestSerializer.m| |____BGAFResponseSerializer.h| |____BGAFResponseSerializer.m| |____BGNetworkCache.h| |____BGNetworkCache.m| |____BGNetworkConfiguration.h| |____BGNetworkConfiguration.m| |____BGNetworkConnector.h| |____BGNetworkConnector.m| |____BGNetworkManager.h| |____BGNetworkManager.m| |____BGNetworkRequest.h| |____BGNetworkRequest.m| |____BGNetworkUtil.h| |____BGNetworkUtil.m</code></pre><p>在 BGNetwork 项目的根目录下创建一个 BGNetwork.podspec 文件，对应上面的需求，我们的 podspec 可以这么写</p><pre><code>Pod::Spec.new do |spec|  #项目名称  spec.name         = &apos;BGNetwork&apos;  #版本号  spec.version      = &apos;0.1.1&apos;  #开源协议  spec.license      = &apos;MIT&apos;  #对开源项目的描述  spec.summary      = &apos;BGNetwork is a request util based on AFNetworking&apos;  #开源项目的首页  spec.homepage     = &apos;https://github.com/eric/BGNetwork&apos;  #作者信息  spec.author       = {&apos;eric&apos; =&gt; &apos;eric@126.com&apos;}  #项目的源和版本号  spec.source       = { :git =&gt; &apos;https://github.com/eric/BGNetwork.git&apos;, :tag =&gt; &apos;0.1.1&apos; }  #源文件，这个就是供第三方使用的源文件  spec.source_files = &quot;BGNetwork/*&quot;  #适用于ios7及以上版本  spec.platform     = :ios, &apos;7.0&apos;  #使用的是ARC  spec.requires_arc = true  #依赖AFNetworking2.0  spec.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.0&apos;end</code></pre><p><strong>注意：spec.source 源是 BGNetwork 的 git 仓库，版本号是我们上一步打上的版本号 0.1.1。</strong></p><h4 id="4、验证并推送到服务器"><a href="#4、验证并推送到服务器" class="headerlink" title="4、验证并推送到服务器"></a>4、验证并推送到服务器</h4><p>在推送前，我们先验证Podspec(检查本地pod)，验证的时候是验证BGNetwork.podspec文件，所以我们需要保证进入的目录和 BGNetwork.podspec 同级的，<br>验证命令如下：</p><pre><code>$ pod lib lint BGNetwork.podspec --no-clean --allow-warnings --verbose或$ pod lib lint # 注意可以在最后面 带上 --sources = ‘’$ pod lib lint BGNetwork.podspec --no-clean --allow-warnings --verbose --sources = &apos;xxxx,https://github.com/CocoaPods/Specs.git&apos;# The sources from which to pull dependent pods(defaults to https://github.com/CocoaPods/Specs.git). Multiple sources must be comma-delimited.# 意思是 这个podspec里面依赖了另一个私有库，为了能找到依赖私有库的地址，需要带上私有库的spec(索引库地址),其中 &apos;xxxx&apos;就是其地址</code></pre><p><strong>注意：验证的时候，会获取 BGNetwork.podspec 文件中的 spec.source 来获取 git 服务器上面对应版本的代码，<br>然后再找到 spec.source_files 中的源代码，通过 xcode 命令行工具建立工程并且进行编译。所以这一步的过程会比较久，如果编译没有错误，就验证通过。<br>建议加上 –fail-fast ，不然每次都是全部编译完成后才报错，当 podspec 很大的时候，会特别费时，加上此参数可以让其停止在错误的地方</strong></p><p>如果没有错误和警告我们就可以推送到服务器了，推送使用的命令如下：</p><pre><code>$ pod repo push REPO_NAME SPEC_NAME.podspec --allow-warnings --verbose# 注意可以在最后面 带上 --sources = ‘’$ pod repo push REPO_NAME SPEC_NAME.podspec --allow-warnings --verbose --sources = &apos;xxxx,https://github.com/CocoaPods/Specs.git&apos;# The sources from which to pull dependent pods(defaults to https://github.com/CocoaPods/Specs.git). Multiple sources must be comma-delimited.# 意思是 这个podspec里面依赖了另一个私有库，为了能找到依赖私有库的地址，需要带上私有库的spec(索引库地址),其中 &apos;xxxx&apos;就是其地址</code></pre><p>它也会先验证，然后再推送。我这里推送 BGNetwork 命令是：</p><pre><code>$ pod repo push eric BGNetwork.podspec</code></pre><p>如果没有错误，但是有警告，我们就将警告解决，也可以加 –allow-warnings 来提交</p><pre><code>$ pod repo push eric BGNetwork.podspec --allow-warnings</code></pre><p>如果有错误，我们可以去查看错误信息对应下的Note信息并解决。在这错误当中，常常会遇到找不到对应文件的错误，这个时候你需要查看<br>BGNetwork.podspec 文件中 spec.source 下 git 仓库链接是否没问题，git 仓库下对应的 tag 版本中 spec.source_files 路径下是否正确。</p><p>如果查看 Note 信息看不出什么问题，可以加上 verbose 参数进行更详细的查看。</p><pre><code>$ pod repo push eric BGNetwork.podspec --allow-warnings --verbose</code></pre><p><strong>注意事项：碰到本地使用 pod lib lint 验证通过，但是 push 到服务器却失败了，这个时候很可能就是服务器 tag 版本不对，使用 –verbose 能查看详细的错误信息。</strong></p><h4 id="5、搜索我们的框架"><a href="#5、搜索我们的框架" class="headerlink" title="5、搜索我们的框架"></a>5、搜索我们的框架</h4><p>到这一步，我们就可以通过 pod search BGNetwork 来搜索了，搜索到了说明我们私有源建立成功。</p><pre><code>$ pod search BGNetwork-&gt; BGNetwork (0.1.2)   BGNetwork is a request util based on AFNetworking   pod &apos;BGNetwork&apos;, &apos;~&gt; 0.1.2&apos;   Homepage: https://github.com/eric/BGNetwork   Source:   https://github.com/eric/BGNetwork.git   Versions: 0.1.1, 0.1.0 [eric repo] - 0.1.2, 0.1.1 [master repo]</code></pre><p>由上面的搜索知道，BGNetwork 在 eric 这个私有 repo 中存在 0.1.1 和 0.1.0 版本，在 master 中存在 0.1.2 和 0.1.1 版本。<br>搜索成功之后，我们将 BGNetwork.podspec 也推送到远程服务器。</p><h3 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h3><h4 id="1、途中遇到了几次问题，就是pod-repo-push不上去，显示没有找到对应文件，后来发现是版本的问题，没有打上版本号或者Podspec中版本错了。"><a href="#1、途中遇到了几次问题，就是pod-repo-push不上去，显示没有找到对应文件，后来发现是版本的问题，没有打上版本号或者Podspec中版本错了。" class="headerlink" title="1、途中遇到了几次问题，就是pod repo push不上去，显示没有找到对应文件，后来发现是版本的问题，没有打上版本号或者Podspec中版本错了。"></a>1、途中遇到了几次问题，就是pod repo push不上去，显示没有找到对应文件，后来发现是版本的问题，没有打上版本号或者Podspec中版本错了。</h4><h4 id="2、若是在框架当中，存在不同的文件夹，请使用-subspec。如果不同文件夹之间的文件有相互导入的情况，请将被导入的头文件设置为-public-header-files，"><a href="#2、若是在框架当中，存在不同的文件夹，请使用-subspec。如果不同文件夹之间的文件有相互导入的情况，请将被导入的头文件设置为-public-header-files，" class="headerlink" title="2、若是在框架当中，存在不同的文件夹，请使用 subspec。如果不同文件夹之间的文件有相互导入的情况，请将被导入的头文件设置为 public_header_files，"></a>2、若是在框架当中，存在不同的文件夹，请使用 subspec。如果不同文件夹之间的文件有相互导入的情况，请将被导入的头文件设置为 public_header_files，</h4><h4 id="并且通过-dependency-设置依赖，具体可以参考-AFNetworking-的-podspec-文件。"><a href="#并且通过-dependency-设置依赖，具体可以参考-AFNetworking-的-podspec-文件。" class="headerlink" title="并且通过 dependency 设置依赖，具体可以参考 AFNetworking 的 podspec 文件。"></a>并且通过 dependency 设置依赖，具体可以参考 AFNetworking 的 podspec 文件。</h4><h4 id="3、若是需要提交给官方，请使用"><a href="#3、若是需要提交给官方，请使用" class="headerlink" title="3、若是需要提交给官方，请使用"></a>3、若是需要提交给官方，请使用</h4><pre><code>$ pod trunk register youremail# 查看信息$ pod trunk me# 将对应的pod推送到服务器$ pod trunk push</code></pre><h4 id="4、使用-pod-install-时，它首先会更新整个官方的源，而-Cocoapods-每天都有很多人提交，所以更新比较慢。所以，建议每过一段时间更新一下官方库，平常的时候，咱们可以在-install-或-update-加一个参数-–no-repo-update-让它不用更新。"><a href="#4、使用-pod-install-时，它首先会更新整个官方的源，而-Cocoapods-每天都有很多人提交，所以更新比较慢。所以，建议每过一段时间更新一下官方库，平常的时候，咱们可以在-install-或-update-加一个参数-–no-repo-update-让它不用更新。" class="headerlink" title="4、使用 pod install 时，它首先会更新整个官方的源，而 Cocoapods 每天都有很多人提交，所以更新比较慢。所以，建议每过一段时间更新一下官方库，平常的时候，咱们可以在 install 或 update 加一个参数 –no-repo-update 让它不用更新。"></a>4、使用 pod install 时，它首先会更新整个官方的源，而 Cocoapods 每天都有很多人提交，所以更新比较慢。所以，建议每过一段时间更新一下官方库，平常的时候，咱们可以在 install 或 update 加一个参数 –no-repo-update 让它不用更新。</h4><pre><code>$ pod install --verbose --no-repo-update$ pod update --verbose --no-repo-update</code></pre><h4 id="5、多个模块"><a href="#5、多个模块" class="headerlink" title="5、多个模块"></a>5、多个模块</h4><p>但如果我们需要拆分出几个子模块让开发者去选择, 这里有两种方案:</p><p>开启多一个Git仓库, 分开来存储<br>通过编写podspec文件的技巧拆分，（参照 AFNetworking)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照官方文档 &lt;a href=&quot;https://guides.cocoapods.org/terminal/commands.html#pod_repo_push&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaPods 官方文档&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/categories/CocoaPods/"/>
    
    
      <category term="CocoaPods" scheme="https://huangzhifei.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS 渲染过程</title>
    <link href="https://huangzhifei.github.io/2018/10/11/Objective-C/2018/iOS%20%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>https://huangzhifei.github.io/2018/10/11/Objective-C/2018/iOS 渲染过程/</id>
    <published>2018-10-11T10:07:58.000Z</published>
    <updated>2020-01-05T02:55:03.365Z</updated>
    
    <content type="html"><![CDATA[<p>参照文章 <a href="https://mp.weixin.qq.com/s/PZfhNiRMSlPSaIFI20gdbQ" target="_blank" rel="noopener">iOS界面渲染流程分析</a></p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p><strong>APP 从点击屏幕到完全渲染出来，这其中发生了一些什么事情？</strong></p><p>1、首先一个视图由CPU进行Frame布局，准备视图和图层的层级关系，查询是否有重写drawRect:或drawLayer:inContext:方法，注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</p><p>2、CPU会将处理视图和图层的层级关系打包，通过IPC（内部处理通信）通道提交给渲染服务，渲染服务由OpenGL ES和GPU组成。</p><p>3、渲染服务首先将图层数据交给OpenGL ES进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</p><p>4、最后，将最终要显示在画面上的后帧缓存交给GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p><strong>一个 UIImageView 添加到视图上以后，内部是如何渲染到手机上的？</strong></p><p>1、获取图片二进制数据。</p><p>2、创建一个CGImageRef对象。</p><p>3、使用CGBitmapContextCreate()方法创建一个上下文对象。</p><p>4、使用CGContextDrawImage()方法绘制到上下文。</p><p>5、使用CGBitmapContextCreateImage()生成CGImageRef对象。</p><p>6、最后使用imageWithCGImage()方法将CGImage转化为UIImage。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p><strong>表中有很多个 cell，每个 cell 上有很多个视图，如何解决卡顿？</strong></p><p>卡顿的定义：当你的主线程操作卡顿超过16.67ms以后，你的应用就会出现掉帧，丢帧的情况。也就是卡顿。</p><p>一般来说造成卡顿的原因，就是CPU负担过重，响应时间过长。主要原因有以下几种：</p><p>1、隐式绘制 CGContext</p><p>2、文本CATextLayer 和 UILabel</p><p>3、光栅化 shouldRasterize</p><p>4、离屏渲染</p><p>5、可伸缩图片</p><p>6、shadowPath</p><p>7、混合和过度绘制</p><p>8、减少图层数量</p><p>9、裁切</p><p>10、对象回收</p><p>11、Core Graphics绘制</p><p>12、- renderInContext: 方法</p><p>参照 YYAsyncLayer 、 AsyncDisplayKit 等三方库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/PZfhNiRMSlPSaIFI20gdbQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS界面渲染流程分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题一&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="iOS技术" scheme="https://huangzhifei.github.io/categories/iOS%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://huangzhifei.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
